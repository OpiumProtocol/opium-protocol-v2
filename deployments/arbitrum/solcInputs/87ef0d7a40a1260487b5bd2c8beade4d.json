{
  "language": "Solidity",
  "sources": {
    "contracts/core/base/RegistryManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/IRegistry.sol\";\n\n/**\n    Error codes:\n    - M1 = ERROR_REGISTRY_MANAGER_ONLY_REGISTRY_MANAGER_ROLE\n    - M2 = ERROR_REGISTRY_MANAGER_ONLY_CORE_CONFIGURATION_UPDATER_ROLE\n */\ncontract RegistryManager is Initializable {\n    event LogRegistryChanged(address indexed _changer, address indexed _newRegistryAddress);\n\n    IRegistry internal registry;\n\n    modifier onlyRegistryManager() {\n        require(registry.isRegistryManager(msg.sender), \"M1\");\n        _;\n    }\n\n    modifier onlyCoreConfigurationUpdater() {\n        require(registry.isCoreConfigurationUpdater(msg.sender), \"M2\");\n        _;\n    }\n\n    function __RegistryManager__init(address _registry) internal initializer {\n        require(_registry != address(0));\n        registry = IRegistry(_registry);\n        emit LogRegistryChanged(msg.sender, _registry);\n    }\n\n    function setRegistry(address _registry) external onlyRegistryManager {\n        registry = IRegistry(_registry);\n        emit LogRegistryChanged(msg.sender, _registry);\n    }\n\n    function getRegistry() external view returns (address) {\n        return address(registry);\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\nimport \"../core/registry/RegistryEntities.sol\";\n\ninterface IRegistry {\n    function initialize(address _governor) external;\n\n    function setProtocolAddresses(\n        address _opiumProxyFactory,\n        address _core,\n        address _oracleAggregator,\n        address _syntheticAggregator,\n        address _tokenSpender\n    ) external;\n\n    function setNoDataCancellationPeriod(uint32 _noDataCancellationPeriod) external;\n\n    function addToWhitelist(address _whitelisted) external;\n\n    function removeFromWhitelist(address _whitelisted) external;\n\n    function setProtocolExecutionReserveClaimer(address _protocolExecutionReserveClaimer) external;\n\n    function setProtocolRedemptionReserveClaimer(address _protocolRedemptionReserveClaimer) external;\n\n    function setProtocolExecutionReservePart(uint32 _protocolExecutionReservePart) external;\n\n    function setDerivativeAuthorExecutionFeeCap(uint32 _derivativeAuthorExecutionFeeCap) external;\n\n    function setProtocolRedemptionReservePart(uint32 _protocolRedemptionReservePart) external;\n\n    function setDerivativeAuthorRedemptionReservePart(uint32 _derivativeAuthorRedemptionReservePart) external;\n\n    function pause() external;\n\n    function pauseProtocolPositionCreation() external;\n\n    function pauseProtocolPositionMinting() external;\n\n    function pauseProtocolPositionRedemption() external;\n\n    function pauseProtocolPositionExecution() external;\n\n    function pauseProtocolPositionCancellation() external;\n\n    function pauseProtocolReserveClaim() external;\n\n    function unpause() external;\n\n    function getProtocolParameters() external view returns (RegistryEntities.ProtocolParametersArgs memory);\n\n    function getProtocolAddresses() external view returns (RegistryEntities.ProtocolAddressesArgs memory);\n\n    function isRegistryManager(address _address) external view returns (bool);\n\n    function isCoreConfigurationUpdater(address _address) external view returns (bool);\n\n    function getCore() external view returns (address);\n\n    function isCoreSpenderWhitelisted(address _address) external view returns (bool);\n\n    function isProtocolPaused() external view returns (bool);\n\n    function isProtocolPositionCreationPaused() external view returns (bool);\n\n    function isProtocolPositionMintingPaused() external view returns (bool);\n\n    function isProtocolPositionRedemptionPaused() external view returns (bool);\n\n    function isProtocolPositionExecutionPaused() external view returns (bool);\n\n    function isProtocolPositionCancellationPaused() external view returns (bool);\n\n    function isProtocolReserveClaimPaused() external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/core/registry/RegistryEntities.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nlibrary RegistryEntities {\n    struct ProtocolParametersArgs {\n        // Period of time after which ticker could be canceled if no data was provided to the `oracleId`\n        uint32 noDataCancellationPeriod;\n        // Max fee that derivative author can set\n        // it works as an upper bound for when the derivative authors set their synthetic's fee\n        uint32 derivativeAuthorExecutionFeeCap;\n        // Fixed part (percentage) that the derivative author receives for each redemption of market neutral positions\n        // It is not set by the derivative authors themselves\n        uint32 derivativeAuthorRedemptionReservePart;\n        // Represents which part of derivative author reserves originated from derivative executions go to the protocol reserves\n        uint32 protocolExecutionReservePart;\n        // Represents which part of derivative author reserves originated from redemption of market neutral positions go to the protocol reserves\n        uint32 protocolRedemptionReservePart;\n        /// Initially uninitialized variables to allow some flexibility in case of future changes and upgradeability\n        uint32 __gapOne;\n        uint32 __gapTwo;\n        uint32 __gapThree;\n    }\n\n    struct ProtocolAddressesArgs {\n        // Address of Opium.Core contract\n        address core;\n        // Address of Opium.OpiumProxyFactory contract\n        address opiumProxyFactory;\n        // Address of Opium.OracleAggregator contract\n        address oracleAggregator;\n        // Address of Opium.SyntheticAggregator contract\n        address syntheticAggregator;\n        // Address of Opium.TokenSpender contract\n        address tokenSpender;\n        // Address of the recipient of execution protocol reserves\n        address protocolExecutionReserveClaimer;\n        // Address of the recipient of redemption protocol reserves\n        address protocolRedemptionReserveClaimer;\n        /// Initially uninitialized variables to allow some flexibility in case of future changes and upgradeability\n        uint32 __gapOne;\n        uint32 __gapTwo;\n    }\n\n    struct ProtocolPausabilityArgs {\n        // if true, all the protocol's entry-points are paused\n        bool protocolGlobal;\n        // if true, no new positions can be created\n        bool protocolPositionCreation;\n        // if true, no new positions can be minted\n        bool protocolPositionMinting;\n        // if true, no new positions can be redeemed\n        bool protocolPositionRedemption;\n        // if true, no new positions can be executed\n        bool protocolPositionExecution;\n        // if true, no new positions can be cancelled\n        bool protocolPositionCancellation;\n        // if true, no reserves can be claimed\n        bool protocolReserveClaim;\n        /// Initially uninitialized variables to allow some flexibility in case of future changes and upgradeability\n        bool __gapOne;\n        bool __gapTwo;\n        bool __gapThree;\n        bool __gapFour;\n    }\n}\n"
    },
    "contracts/core/TokenSpender.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./base/RegistryManager.sol\";\nimport \"../interfaces/IRegistry.sol\";\n\n/**\n    Error codes:\n    - T1 = ERROR_TOKEN_SPENDER_NOT_WHITELISTED\n */\n\n/// @title Opium.TokenSpender contract holds users ERC20 allowances and allows whitelisted contracts to use ERC20 tokens\ncontract TokenSpender is RegistryManager {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    modifier onlyCoreSpenders() {\n        require(registry.isCoreSpenderWhitelisted(msg.sender), \"T1\");\n        _;\n    }\n\n    /// @notice it is called only once upon deployment of the contract\n    /// @param _registry sets the address of the Opium.Registry\n    function initialize(address _registry) external initializer {\n        __RegistryManager__init(_registry);\n    }\n\n    /// @notice Using this function whitelisted contracts could call ERC20 transfers\n    /// @param _token IERC20 Instance of token\n    /// @param _from address Address from which tokens are transferred\n    /// @param _to address Address of tokens receiver\n    /// @param _amount uint256 Amount of tokens to be transferred\n    function claimTokens(\n        IERC20Upgradeable _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external onlyCoreSpenders {\n        _token.safeTransferFrom(_from, _to, _amount);\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/test/upgradeability/TestTokenSpenderUpgrade.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../../core/TokenSpender.sol\";\n\ncontract TestTokenSpenderUpgrade is TokenSpender {\n    function placeholder() external pure returns (string memory) {\n        return \"upgraded\";\n    }\n}\n"
    },
    "contracts/test/mocks/oracles/OracleIdMock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../../../interfaces/IRegistry.sol\";\nimport \"../../../interfaces/IOracleAggregator.sol\";\n\ncontract OracleIdMock {\n    uint256 fetchPrice;\n    IRegistry registry;\n\n    constructor(uint256 _fetchPrice, address _registry) {\n        fetchPrice = _fetchPrice;\n        registry = IRegistry(_registry);\n    }\n\n    function triggerCallback(uint256 timestamp, uint256 returnData) external {\n        IOracleAggregator(registry.getProtocolAddresses().oracleAggregator).__callback(timestamp, returnData);\n    }\n}\n"
    },
    "contracts/interfaces/IOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\ninterface IOracleAggregator {\n    function __callback(uint256 timestamp, uint256 data) external;\n\n    function getData(address oracleId, uint256 timestamp) external view returns (uint256 dataResult);\n\n    function hasData(address oracleId, uint256 timestamp) external view returns (bool);\n}\n"
    },
    "contracts/test/mocks/oracles/ChainlinkOracleSubId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"hardhat/console.sol\";\nimport \"../../../interfaces/IRegistry.sol\";\nimport \"../../../interfaces/IOracleAggregator.sol\";\n\ncontract ChainlinkOracleSubId {\n    event LogDataProvision(address _from, address _to, uint256 _timestamp, uint256 _data);\n    // AAVE/ETH price feed (18 decimals)\n    AggregatorV3Interface private constant priceFeed =\n        AggregatorV3Interface(0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012);\n    // Opium Protocol Registry\n    IRegistry private immutable registry;\n\n    constructor(address _registry) {\n        registry = IRegistry(_registry);\n    }\n\n    /// @param _derivativeEndTime uint256 the maturity of the derivative contract that uses ChainlinkOracleSubId as its oracleId\n    function triggerCallback(uint256 _derivativeEndTime) external {\n        // fetches the data and the timestamp from the Chainlink pricefeed\n        (uint256 price, uint256 timestamp) = getLatestPrice();\n        // fetches the Opium.OracleAggregator from the Opium.Registry\n        IOracleAggregator oracleAggregator = IOracleAggregator(registry.getProtocolAddresses().oracleAggregator);\n        // logs the relevant event\n        emit LogDataProvision(address(priceFeed), address(oracleAggregator), timestamp, price);\n        // pushes the data into the OracleAggregator\n        oracleAggregator.__callback(_derivativeEndTime, price);\n    }\n\n    function getLatestPrice() private view returns (uint256, uint256) {\n        (, int256 price, , uint256 timestamp, ) = priceFeed.latestRoundData();\n        return (uint256(price), timestamp);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/core/registry/Registry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"../../libs/LibRoles.sol\";\nimport \"../../libs/LibCalculator.sol\";\nimport \"../../interfaces/IOpiumProxyFactory.sol\";\nimport \"../../interfaces/ISyntheticAggregator.sol\";\nimport \"../../interfaces/IOracleAggregator.sol\";\nimport \"../../interfaces/ITokenSpender.sol\";\nimport \"../../interfaces/ICore.sol\";\n\n/**\n    Error codes:\n    - R1 = ERROR_REGISTRY_ONLY_PROTOCOL_ADDRESSES_SETTER_ROLE\n    - R2 = ERROR_REGISTRY_ONLY_EXECUTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE\n    - R3 = ERROR_REGISTRY_ONLY_REDEMPTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE\n    - R4 = ERROR_REGISTRY_ONLY_EXECUTION_RESERVE_PART_SETTER_ROLE\n    - R5 = ERROR_REGISTRY_ONLY_NO_DATA_CANCELLATION_PERIOD_SETTER_ROLE\n    - R6 = ERROR_REGISTRY_ONLY_GUARDIAN_ROLE\n    - R7 = ERROR_REGISTRY_ONLY_WHITELISTER_ROLE\n    - R8 = ERROR_REGISTRY_ONLY_DERIVATIVE_AUTHOR_EXECUTION_FEE_CAP_SETTER_ROLE\n    - R9 = ERROR_REGISTRY_ONLY_REDEMPTION_RESERVE_PART_SETTER_ROLE\n    - R10 = ERROR_REGISTRY_ALREADY_PAUSED\n    - R11 = ERROR_REGISTRY_NOT_PAUSED\n    - R12 = ERROR_REGISTRY_NULL_ADDRESS\n    - R13 = ERROR_REGISTRY_ONLY_PARTIAL_CREATE_PAUSE_ROLE\n    - R14 = ERROR_REGISTRY_ONLY_PARTIAL_MINT_PAUSE_ROLE\n    - R15 = ERROR_REGISTRY_ONLY_PARTIAL_REDEEM_PAUSE_ROLE\n    - R16 = ERROR_REGISTRY_ONLY_PARTIAL_EXECUTE_PAUSE_ROLE\n    - R17 = ERROR_REGISTRY_ONLY_PARTIAL_CANCEL_PAUSE_ROLE\n    - R18 = ERROR_REGISTRY_ONLY_PARTIAL_CLAIM_RESERVE_PAUSE_ROLE\n    - R19 = ERROR_REGISTRY_ONLY_PROTOCOL_UNPAUSER_ROLE\n    - R20 = ERROR_REGISTRY_INVALID_VALUE\n */\n\ncontract Registry is AccessControlUpgradeable {\n    // Setup\n    event LogNoDataCancellationPeriodChanged(address indexed _setter, uint256 indexed _noDataCancellationPeriod);\n    event LogWhitelistAccountAdded(address indexed _setter, address indexed _whitelisted);\n    event LogWhitelistAccountRemoved(address indexed _setter, address indexed _unlisted);\n    // Reserve\n    event LogProtocolExecutionReserveClaimerChanged(\n        address indexed _setter,\n        address indexed _protocolExecutionReserveClaimer\n    );\n    event LogProtocolRedemptionReserveClaimerChanged(\n        address indexed _setter,\n        address indexed _protocolRedemptionReserveClaimer\n    );\n    event LogProtocolExecutionReservePartChanged(address indexed _setter, uint32 indexed _protocolExecutionReservePart);\n    event LogDerivativeAuthorExecutionFeeCapChanged(\n        address indexed _setter,\n        uint32 indexed _derivativeAuthorExecutionFeeCap\n    );\n    event LogProtocolRedemptionReservePartChanged(\n        address indexed _setter,\n        uint32 indexed _protocolRedemptionReservePart\n    );\n    event LogDerivativeAuthorRedemptionReservePartChanged(\n        address indexed _setter,\n        uint32 indexed _derivativeAuthorRedemptionReservePart\n    );\n    // Emergency\n    // emits the role to signal what type of pause has been committed, if any\n    event LogProtocolPausableStateChanged(address indexed _setter, bool indexed _state, bytes32 indexed _role);\n\n    RegistryEntities.ProtocolParametersArgs private protocolParametersArgs;\n    RegistryEntities.ProtocolAddressesArgs private protocolAddressesArgs;\n    RegistryEntities.ProtocolPausabilityArgs private protocolPausabilityArgs;\n    mapping(address => bool) private coreSpenderWhitelist;\n\n    // ***** SETUP *****\n\n    /// @notice it ensures that the calling account has been granted the PROTOCOL_ADDRESSES_SETTER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyProtocolAdressesSetter() {\n        require(hasRole(LibRoles.PROTOCOL_ADDRESSES_SETTER_ROLE, msg.sender), \"R1\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the NO_DATA_CANCELLATION_PERIOD_SETTER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyNoDataCancellationPeriodSetter() {\n        require(hasRole(LibRoles.NO_DATA_CANCELLATION_PERIOD_SETTER_ROLE, msg.sender), \"R5\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the WHITELISTER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyWhitelister() {\n        require(hasRole(LibRoles.WHITELISTER_ROLE, msg.sender), \"R7\");\n        _;\n    }\n\n    // ***** RESERVE *****\n\n    /// @notice it ensures that the calling account has been granted the EXECUTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyProtocolExecutionReserveClaimerAddressSetter() {\n        require(hasRole(LibRoles.EXECUTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE, msg.sender), \"R2\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the REDEMPTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyProtocolRedemptionReserveClaimerAddressSetter() {\n        require(hasRole(LibRoles.REDEMPTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE, msg.sender), \"R3\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the EXECUTION_RESERVE_PART_SETTER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyProtocolExecutionReservePartSetter() {\n        require(hasRole(LibRoles.EXECUTION_RESERVE_PART_SETTER_ROLE, msg.sender), \"R4\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the DERIVATIVE_AUTHOR_EXECUTION_FEE_CAP_SETTER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyDerivativeAuthorExecutionFeeCapSetter() {\n        require(hasRole(LibRoles.DERIVATIVE_AUTHOR_EXECUTION_FEE_CAP_SETTER_ROLE, msg.sender), \"R8\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the REDEMPTION_RESERVE_PART_SETTER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyProtocolRedemptionReservePartSetter() {\n        require(hasRole(LibRoles.REDEMPTION_RESERVE_PART_SETTER_ROLE, msg.sender), \"R9\");\n        _;\n    }\n\n    // ***** EMERGENCY *****\n\n    /// @notice it ensures that the calling account has been granted the GUARDIAN_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyGuardian() {\n        require(hasRole(LibRoles.GUARDIAN_ROLE, msg.sender), \"R6\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the PARTIAL_CREATE_PAUSE_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyPartialCreatePauseSetter() {\n        require(hasRole(LibRoles.PARTIAL_CREATE_PAUSE_ROLE, msg.sender), \"R13\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the PARTIAL_MINT_PAUSE_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyPartialMintPauseSetter() {\n        require(hasRole(LibRoles.PARTIAL_MINT_PAUSE_ROLE, msg.sender), \"R14\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the PARTIAL_REDEEM_PAUSE_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyPartialRedeemPauseSetter() {\n        require(hasRole(LibRoles.PARTIAL_REDEEM_PAUSE_ROLE, msg.sender), \"R15\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the PARTIAL_EXECUTE_PAUSE_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyPartialExecutePauseSetter() {\n        require(hasRole(LibRoles.PARTIAL_EXECUTE_PAUSE_ROLE, msg.sender), \"R16\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the PARTIAL_CANCEL_PAUSE_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyPartialCancelPauseSetter() {\n        require(hasRole(LibRoles.PARTIAL_CANCEL_PAUSE_ROLE, msg.sender), \"R17\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the PARTIAL_CLAIM_RESERVE_PAUSE_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyPartialClaimReservePauseSetter() {\n        require(hasRole(LibRoles.PARTIAL_CLAIM_RESERVE_PAUSE_ROLE, msg.sender), \"R18\");\n        _;\n    }\n\n    /// @notice it ensures that the calling account has been granted the PROTOCOL_UNPAUSER_ROLE\n    /// @dev by default, it is granted to the `governor` account\n    modifier onlyProtocolUnpauserSetter() {\n        require(hasRole(LibRoles.PROTOCOL_UNPAUSER_ROLE, msg.sender), \"R19\");\n        _;\n    }\n\n    // ****************** EXTERNAL FUNCTIONS ******************\n\n    // ***** SETTERS *****\n\n    /// @notice it is called only once upon deployment of the contract. It initializes the DEFAULT_ADMIN_ROLE with the given governor address.\n    /// @notice it sets the default ProtocolParametersArgs protocol parameters\n    /// @dev internally, it assigns all the setters roles to the DEFAULT_ADMIN_ROLE and it sets the initial protocol parameters\n    /// @param _governor address of the governance account which will be assigned all the roles included in the LibRoles library and the OpenZeppelin AccessControl.DEFAULT_ADMIN_ROLE\n    function initialize(address _governor) external initializer {\n        __AccessControl_init();\n\n        // Setup\n        _setupRole(DEFAULT_ADMIN_ROLE, _governor);\n        _setupRole(LibRoles.PROTOCOL_ADDRESSES_SETTER_ROLE, _governor);\n        _setupRole(LibRoles.NO_DATA_CANCELLATION_PERIOD_SETTER_ROLE, _governor);\n        _setupRole(LibRoles.WHITELISTER_ROLE, _governor);\n        _setupRole(LibRoles.REGISTRY_MANAGER_ROLE, _governor);\n        _setupRole(LibRoles.CORE_CONFIGURATION_UPDATER_ROLE, _governor);\n\n        // Reserve\n        _setupRole(LibRoles.EXECUTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE, _governor);\n        _setupRole(LibRoles.REDEMPTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE, _governor);\n        _setupRole(LibRoles.EXECUTION_RESERVE_PART_SETTER_ROLE, _governor);\n        _setupRole(LibRoles.DERIVATIVE_AUTHOR_EXECUTION_FEE_CAP_SETTER_ROLE, _governor);\n        _setupRole(LibRoles.REDEMPTION_RESERVE_PART_SETTER_ROLE, _governor);\n\n        // Emergency\n        _setupRole(LibRoles.GUARDIAN_ROLE, _governor);\n        _setupRole(LibRoles.PARTIAL_CREATE_PAUSE_ROLE, _governor);\n        _setupRole(LibRoles.PARTIAL_MINT_PAUSE_ROLE, _governor);\n        _setupRole(LibRoles.PARTIAL_REDEEM_PAUSE_ROLE, _governor);\n        _setupRole(LibRoles.PARTIAL_EXECUTE_PAUSE_ROLE, _governor);\n        _setupRole(LibRoles.PARTIAL_CANCEL_PAUSE_ROLE, _governor);\n        _setupRole(LibRoles.PARTIAL_CLAIM_RESERVE_PAUSE_ROLE, _governor);\n        _setupRole(LibRoles.PROTOCOL_UNPAUSER_ROLE, _governor);\n\n        // Default protocol parameters\n        protocolParametersArgs.noDataCancellationPeriod = 2 weeks;\n        protocolParametersArgs.derivativeAuthorExecutionFeeCap = 1000; // 10%\n        protocolParametersArgs.derivativeAuthorRedemptionReservePart = 10; // 0.1%\n        protocolParametersArgs.protocolExecutionReservePart = 1000; // 10%\n        protocolParametersArgs.protocolRedemptionReservePart = 1000; // 10%\n    }\n\n    // ** ROLE-RESTRICTED FUNCTIONS **\n\n    // * Setup *\n\n    /// @notice It allows the PROTOCOL_ADDRESSES_SETTER_ROLE role to set the addresses of Opium Protocol's contracts\n    /// @dev It must be called as part of the protocol's deployment setup after the core addresses have been deployed\n    /// @dev the contracts' addresses are set using their respective interfaces\n    /// @param _opiumProxyFactory address of Opium.OpiumProxyFactory\n    /// @param _core address of Opium.Core\n    /// @param _oracleAggregator address of Opium.OracleAggregator\n    /// @param _syntheticAggregator address of Opium.SyntheticAggregator\n    /// @param _tokenSpender address of Opium.TokenSpender\n    function setProtocolAddresses(\n        address _opiumProxyFactory,\n        address _core,\n        address _oracleAggregator,\n        address _syntheticAggregator,\n        address _tokenSpender\n    ) external onlyProtocolAdressesSetter {\n        require(\n            _opiumProxyFactory != address(0) &&\n                _core != address(0) &&\n                _oracleAggregator != address(0) &&\n                _syntheticAggregator != address(0) &&\n                _tokenSpender != address(0),\n            \"R12\"\n        );\n        protocolAddressesArgs.opiumProxyFactory = _opiumProxyFactory;\n        protocolAddressesArgs.core = _core;\n        protocolAddressesArgs.oracleAggregator = _oracleAggregator;\n        protocolAddressesArgs.syntheticAggregator = _syntheticAggregator;\n        protocolAddressesArgs.tokenSpender = _tokenSpender;\n    }\n\n    /// @notice It allows the NO_DATA_CANCELLATION_PERIOD_SETTER_ROLE role to change the noDataCancellationPeriod (the timeframe after which a derivative can be cancelled if the oracle has not provided any data)\n    function setNoDataCancellationPeriod(uint32 _noDataCancellationPeriod) external onlyNoDataCancellationPeriodSetter {\n        protocolParametersArgs.noDataCancellationPeriod = _noDataCancellationPeriod;\n        emit LogNoDataCancellationPeriodChanged(msg.sender, _noDataCancellationPeriod);\n    }\n\n    /// @notice It allows the WHITELISTER_ROLE to add an address to the whitelist\n    function addToWhitelist(address _whitelisted) external onlyWhitelister {\n        coreSpenderWhitelist[_whitelisted] = true;\n        emit LogWhitelistAccountAdded(msg.sender, _whitelisted);\n    }\n\n    /// @notice It allows the WHITELISTER_ROLE to remove an address from the whitelist\n    function removeFromWhitelist(address _whitelisted) external onlyWhitelister {\n        coreSpenderWhitelist[_whitelisted] = false;\n        emit LogWhitelistAccountRemoved(msg.sender, _whitelisted);\n    }\n\n    // * Reserve *\n\n    /// @notice It allows the EXECUTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE role to change the address of the recipient of execution protocol reserves\n    /// @dev It must be called as part of the protocol's deployment setup after the core addresses have been deployed\n    /// @dev it must be a non-null address\n    /// @param _protocolExecutionReserveClaimer address that will replace the current `protocolExecutionReserveClaimer`\n    function setProtocolExecutionReserveClaimer(address _protocolExecutionReserveClaimer)\n        external\n        onlyProtocolExecutionReserveClaimerAddressSetter\n    {\n        require(_protocolExecutionReserveClaimer != address(0), \"R12\");\n        protocolAddressesArgs.protocolExecutionReserveClaimer = _protocolExecutionReserveClaimer;\n        emit LogProtocolExecutionReserveClaimerChanged(msg.sender, _protocolExecutionReserveClaimer);\n    }\n\n    /// @notice It allows the REDEMPTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE role to change the address of the recipient of redemption protocol reserves\n    /// @dev It must be called as part of the protocol's deployment setup after the core addresses have been deployed\n    /// @dev it must be a non-null address\n    /// @param _protocolRedemptionReserveClaimer address that will replace the current `protocolAddressesArgs.protocolRedemptionReserveClaimer`\n    function setProtocolRedemptionReserveClaimer(address _protocolRedemptionReserveClaimer)\n        external\n        onlyProtocolRedemptionReserveClaimerAddressSetter\n    {\n        require(_protocolRedemptionReserveClaimer != address(0), \"R12\");\n        protocolAddressesArgs.protocolRedemptionReserveClaimer = _protocolRedemptionReserveClaimer;\n        emit LogProtocolRedemptionReserveClaimerChanged(msg.sender, _protocolRedemptionReserveClaimer);\n    }\n\n    /// @notice It allows the EXECUTION_RESERVE_PART_SETTER_ROLE role to change part of derivative author reserves originated from derivative executions go to the protocol reserves\n    /// @param _protocolExecutionReservePart must be less than 100%\n    function setProtocolExecutionReservePart(uint32 _protocolExecutionReservePart)\n        external\n        onlyProtocolExecutionReservePartSetter\n    {\n        require(_protocolExecutionReservePart < LibCalculator.PERCENTAGE_BASE, \"R20\");\n        protocolParametersArgs.protocolExecutionReservePart = _protocolExecutionReservePart;\n        emit LogProtocolExecutionReservePartChanged(msg.sender, _protocolExecutionReservePart);\n    }\n\n    /// @notice It allows the DERIVATIVE_AUTHOR_EXECUTION_FEE_CAP_SETTER_ROLE role to change max fee that derivative author can set\n    /// @param _derivativeAuthorExecutionFeeCap must be less than 100%\n    function setDerivativeAuthorExecutionFeeCap(uint32 _derivativeAuthorExecutionFeeCap)\n        external\n        onlyDerivativeAuthorExecutionFeeCapSetter\n    {\n        require(_derivativeAuthorExecutionFeeCap < LibCalculator.PERCENTAGE_BASE, \"R20\");\n        protocolParametersArgs.derivativeAuthorExecutionFeeCap = _derivativeAuthorExecutionFeeCap;\n        emit LogDerivativeAuthorExecutionFeeCapChanged(msg.sender, _derivativeAuthorExecutionFeeCap);\n    }\n\n    /// @notice It allows the REDEMPTION_RESERVE_PART_SETTER_ROLE role to change part of derivative author reserves originated from redemption of market neutral positions go to the protocol reserves\n    /// @param _protocolRedemptionReservePart must be less than 100%\n    function setProtocolRedemptionReservePart(uint32 _protocolRedemptionReservePart)\n        external\n        onlyProtocolRedemptionReservePartSetter\n    {\n        require(_protocolRedemptionReservePart < LibCalculator.PERCENTAGE_BASE, \"R20\");\n        protocolParametersArgs.protocolRedemptionReservePart = _protocolRedemptionReservePart;\n        emit LogProtocolRedemptionReservePartChanged(msg.sender, _protocolRedemptionReservePart);\n    }\n\n    /// @notice It allows the REDEMPTION_RESERVE_PART_SETTER_ROLE role to change the fixed part (percentage) that the derivative author receives for each redemption of market neutral positions\n    /// @param _derivativeAuthorRedemptionReservePart must be less than 1%\n    function setDerivativeAuthorRedemptionReservePart(uint32 _derivativeAuthorRedemptionReservePart)\n        external\n        onlyProtocolRedemptionReservePartSetter\n    {\n        require(_derivativeAuthorRedemptionReservePart <= LibCalculator.MAX_REDEMPTION_PART, \"R20\");\n        protocolParametersArgs.derivativeAuthorRedemptionReservePart = _derivativeAuthorRedemptionReservePart;\n        emit LogDerivativeAuthorRedemptionReservePartChanged(msg.sender, _derivativeAuthorRedemptionReservePart);\n    }\n\n    // * Emergency *\n\n    /// @notice It allows the GUARDIAN role to pause the entire Opium Protocol\n    /// @dev it fails if the entire protocol is already paused\n    function pause() external onlyGuardian {\n        require(!protocolPausabilityArgs.protocolGlobal, \"R10\");\n        protocolPausabilityArgs.protocolGlobal = true;\n        emit LogProtocolPausableStateChanged(msg.sender, true, LibRoles.GUARDIAN_ROLE);\n    }\n\n    /// @notice It allows the PARTIAL_CREATE_PAUSE_ROLE role to pause the creation of positions\n    /// @dev it fails if the creation of positions is paused\n    function pauseProtocolPositionCreation() external onlyPartialCreatePauseSetter {\n        require(!protocolPausabilityArgs.protocolPositionCreation, \"R10\");\n        protocolPausabilityArgs.protocolPositionCreation = true;\n        emit LogProtocolPausableStateChanged(msg.sender, true, LibRoles.PARTIAL_CREATE_PAUSE_ROLE);\n    }\n\n    /// @notice It allows the PARTIAL_MINT_PAUSE_ROLE role to pause the minting of positions\n    /// @dev it fails if the minting of positions is paused\n    function pauseProtocolPositionMinting() external onlyPartialMintPauseSetter {\n        require(!protocolPausabilityArgs.protocolPositionMinting, \"R10\");\n        protocolPausabilityArgs.protocolPositionMinting = true;\n        emit LogProtocolPausableStateChanged(msg.sender, true, LibRoles.PARTIAL_MINT_PAUSE_ROLE);\n    }\n\n    /// @notice It allows the PARTIAL_REDEEM_PAUSE_ROLE role to pause the redemption of positions\n    /// @dev it fails if the redemption of positions is paused\n    function pauseProtocolPositionRedemption() external onlyPartialRedeemPauseSetter {\n        require(!protocolPausabilityArgs.protocolPositionRedemption, \"R10\");\n        protocolPausabilityArgs.protocolPositionRedemption = true;\n        emit LogProtocolPausableStateChanged(msg.sender, true, LibRoles.PARTIAL_REDEEM_PAUSE_ROLE);\n    }\n\n    /// @notice It allows the PARTIAL_EXECUTE_PAUSE_ROLE role to pause the execution of positions\n    /// @dev it fails if the execution of positions is paused\n    function pauseProtocolPositionExecution() external onlyPartialExecutePauseSetter {\n        require(!protocolPausabilityArgs.protocolPositionExecution, \"R10\");\n        protocolPausabilityArgs.protocolPositionExecution = true;\n        emit LogProtocolPausableStateChanged(msg.sender, true, LibRoles.PARTIAL_EXECUTE_PAUSE_ROLE);\n    }\n\n    /// @notice It allows the PARTIAL_CANCEL_PAUSE_ROLE role to pause the cancellation of positions\n    /// @dev it fails if the cancellation of positions is paused\n    function pauseProtocolPositionCancellation() external onlyPartialCancelPauseSetter {\n        require(!protocolPausabilityArgs.protocolPositionCancellation, \"R10\");\n        protocolPausabilityArgs.protocolPositionCancellation = true;\n        emit LogProtocolPausableStateChanged(msg.sender, true, LibRoles.PARTIAL_CANCEL_PAUSE_ROLE);\n    }\n\n    /// @notice It allows the PARTIAL_CLAIM_RESERVE_PAUSE_ROLE role to pause the reserves claims\n    /// @dev it fails if the reserves claims are paused\n    function pauseProtocolReserveClaim() external onlyPartialClaimReservePauseSetter {\n        require(!protocolPausabilityArgs.protocolReserveClaim, \"R10\");\n        protocolPausabilityArgs.protocolReserveClaim = true;\n        emit LogProtocolPausableStateChanged(msg.sender, true, LibRoles.PARTIAL_CLAIM_RESERVE_PAUSE_ROLE);\n    }\n\n    /// @notice It allows the PROTOCOL_UNPAUSER_ROLE to unpause the Opium Protocol\n    function unpause() external onlyProtocolUnpauserSetter {\n        delete protocolPausabilityArgs;\n        emit LogProtocolPausableStateChanged(msg.sender, false, LibRoles.PROTOCOL_UNPAUSER_ROLE);\n    }\n\n    // ***** GETTERS *****\n\n    ///@return RegistryEntities.getProtocolParameters struct that packs the protocol lifecycle parameters {see RegistryEntities comments}\n    function getProtocolParameters() external view returns (RegistryEntities.ProtocolParametersArgs memory) {\n        return protocolParametersArgs;\n    }\n\n    ///@return RegistryEntities.ProtocolAddressesArgs struct that packs all the interfaces of the Opium Protocol\n    function getProtocolAddresses() external view returns (RegistryEntities.ProtocolAddressesArgs memory) {\n        return protocolAddressesArgs;\n    }\n\n    /// @notice Returns true if msg.sender has been assigned the REGISTRY_MANAGER_ROLE role\n    /// @dev it is meant to be consumed by the RegistryManager module\n    /// @param _address address to be checked\n    function isRegistryManager(address _address) external view returns (bool) {\n        return hasRole(LibRoles.REGISTRY_MANAGER_ROLE, _address);\n    }\n\n    /// @notice Returns true if msg.sender has been assigned the CORE_CONFIGURATION_UPDATER_ROLE role\n    /// @dev it is meant to be consumed by the RegistryManager module\n    /// @param _address address to be checked\n    function isCoreConfigurationUpdater(address _address) external view returns (bool) {\n        return hasRole(LibRoles.CORE_CONFIGURATION_UPDATER_ROLE, _address);\n    }\n\n    /// @return `Opium.Core`\n    function getCore() external view returns (address) {\n        return address(protocolAddressesArgs.core);\n    }\n\n    /// @notice It returns whether a given address is allowed to manage Opium.Core ERC20 balances\n    function isCoreSpenderWhitelisted(address _address) external view returns (bool) {\n        return coreSpenderWhitelist[_address];\n    }\n\n    /// @notice It returns true if the protocol is globally paused\n    function isProtocolPaused() external view returns (bool) {\n        return protocolPausabilityArgs.protocolGlobal;\n    }\n\n    /// @notice It returns whether Core.create() is currently paused\n    /// @return true if protocol is globally paused or if protocolPositionCreation is paused\n    function isProtocolPositionCreationPaused() external view returns (bool) {\n        return protocolPausabilityArgs.protocolGlobal || protocolPausabilityArgs.protocolPositionCreation;\n    }\n\n    /// @notice It returns whether Core.mint() is currently paused\n    /// @return true if protocol is globally paused or if protocolPositionMinting is paused\n    function isProtocolPositionMintingPaused() external view returns (bool) {\n        return protocolPausabilityArgs.protocolGlobal || protocolPausabilityArgs.protocolPositionMinting;\n    }\n\n    /// @notice It returns whether Core.redeem() is currently paused\n    /// @return true if protocol is globally paused or if protocolPositionRedemption is paused\n    function isProtocolPositionRedemptionPaused() external view returns (bool) {\n        return protocolPausabilityArgs.protocolGlobal || protocolPausabilityArgs.protocolPositionRedemption;\n    }\n\n    /// @notice It returns whether Core.execute() is currently paused\n    /// @return true if protocol is globally paused or if protocolPositionExecution is paused\n    function isProtocolPositionExecutionPaused() external view returns (bool) {\n        return protocolPausabilityArgs.protocolGlobal || protocolPausabilityArgs.protocolPositionExecution;\n    }\n\n    /// @notice It returns whether Core.cancel() is currently paused\n    /// @return true if protocol is globally paused or if protocolPositionCancellation is paused\n    function isProtocolPositionCancellationPaused() external view returns (bool) {\n        return protocolPausabilityArgs.protocolGlobal || protocolPausabilityArgs.protocolPositionCancellation;\n    }\n\n    /// @notice It returns whether Core.execute() is currently paused\n    /// @return true if protocol is globally paused or if protocolReserveClaim is paused\n    function isProtocolReserveClaimPaused() external view returns (bool) {\n        return protocolPausabilityArgs.protocolGlobal || protocolPausabilityArgs.protocolReserveClaim;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/libs/LibRoles.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nlibrary LibRoles {\n    // ***** SETUP *****\n\n    /// @notice Role responsible for updating the Opium Protocol core contracts' addresses encoded in the RegistryEntities.ProtocolAddressesArgs struct\n    /// @dev { See RegistryEntities.sol for a detailed description of the struct }\n    bytes32 internal constant PROTOCOL_ADDRESSES_SETTER_ROLE = keccak256(\"RL1\");\n\n    /// @notice Role responsible for updating the RegistryEntities.ProtocolParametersArgs.noDataCancellationPeriod\n    /// @dev { See RegistryEntities.sol for a detailed description of the ProtocolParametersArgs parameters }\n    bytes32 internal constant NO_DATA_CANCELLATION_PERIOD_SETTER_ROLE = keccak256(\"RL5\");\n\n    /// @notice Role responsible for managing (adding and removing accounts) the whitelist\n    bytes32 internal constant WHITELISTER_ROLE = keccak256(\"RL7\");\n\n    /// @notice Role responsible for updating the Registry address itself stored in the Opium Protocol core contracts that consume the Registry\n    /// @dev It is the only role whose associated setter does not reside in the Registry itself but in a module inherited by its consumer contracts.\n    /// @dev The registry's sole responsibility is to keep track of the accounts that have been assigned to the REGISTRY_MANAGER_ROLE role\n    /// @dev { See RegistryManager.sol for further details }\n    bytes32 internal constant REGISTRY_MANAGER_ROLE = keccak256(\"RL10\");\n\n    /// @notice Role responsible for updating (applying) new core configuration if it was changed in the registry\n    bytes32 internal constant CORE_CONFIGURATION_UPDATER_ROLE = keccak256(\"RL18\");\n\n    // ***** RESERVE *****\n\n    /// @notice Role responsible for updating the reserve recipient's address of the profitable execution of derivatives positions\n    bytes32 internal constant EXECUTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE = keccak256(\"RL2\");\n\n    /// @notice Role responsible for updating the reserve recipient's address of the redemption of market neutral positions\n    bytes32 internal constant REDEMPTION_RESERVE_CLAIMER_ADDRESS_SETTER_ROLE = keccak256(\"RL3\");\n\n    /// @notice Role responsible for updating the fixed part (percentage) of the derivative author fees that goes to the protocol execution reserve\n    bytes32 internal constant EXECUTION_RESERVE_PART_SETTER_ROLE = keccak256(\"RL4\");\n\n    /// @notice Role responsible for updating the maximum fee that a derivative author can set as a commission originated from the profitable execution of derivatives positions\n    bytes32 internal constant DERIVATIVE_AUTHOR_EXECUTION_FEE_CAP_SETTER_ROLE = keccak256(\"RL8\");\n\n    /// @notice Role responsible for updating the fixed part (percentage) of the initial margin that will be deducted to the reserves during redemption of market neutral positions\n    /// @notice Also sets fixed part (percentage) of this redemption reserves that goes to the protocol redemption reserve\n    bytes32 internal constant REDEMPTION_RESERVE_PART_SETTER_ROLE = keccak256(\"RL9\");\n\n    // ***** EMERGENCY *****\n\n    /// @notice Role responsible for globally pausing the protocol\n    bytes32 internal constant GUARDIAN_ROLE = keccak256(\"RL6\");\n\n    /// @notice Role responsible for pausing Core.create\n    bytes32 internal constant PARTIAL_CREATE_PAUSE_ROLE = keccak256(\"RL11\");\n\n    /// @notice Role responsible for pausing Core.mint\n    bytes32 internal constant PARTIAL_MINT_PAUSE_ROLE = keccak256(\"RL12\");\n\n    /// @notice Role responsible for pausing Core.redeem\n    bytes32 internal constant PARTIAL_REDEEM_PAUSE_ROLE = keccak256(\"RL13\");\n\n    /// @notice Role responsible for pausing Core.execute\n    bytes32 internal constant PARTIAL_EXECUTE_PAUSE_ROLE = keccak256(\"RL14\");\n\n    /// @notice Role responsible for pausing Core.cancel\n    bytes32 internal constant PARTIAL_CANCEL_PAUSE_ROLE = keccak256(\"RL15\");\n\n    /// @notice Role responsible for pausing Core.claimReserve\n    bytes32 internal constant PARTIAL_CLAIM_RESERVE_PAUSE_ROLE = keccak256(\"RL16\");\n\n    /// @notice Role responsible for globally unpausing the protocol\n    bytes32 internal constant PROTOCOL_UNPAUSER_ROLE = keccak256(\"RL17\");\n}\n"
    },
    "contracts/libs/LibCalculator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nlibrary LibCalculator {\n    uint256 internal constant PERCENTAGE_BASE = 10000; // Represents 100%\n    uint256 internal constant MAX_REDEMPTION_PART = 100; // Represents 1%\n\n    function mulWithPrecisionFactor(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        return (_x * _y) / 1e18;\n    }\n\n    function modWithPrecisionFactor(uint256 _x) internal pure returns (uint256) {\n        return _x % 1e18;\n    }\n}\n"
    },
    "contracts/interfaces/IOpiumProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\nimport \"../libs/LibDerivative.sol\";\n\ninterface IOpiumProxyFactory {\n    function getImplementationAddress() external view returns (address);\n\n    function initialize(address _registry) external;\n\n    function create(\n        address _buyer,\n        address _seller,\n        uint256 _amount,\n        bytes32 _derivativeHash,\n        LibDerivative.Derivative calldata _derivative\n    ) external;\n\n    function mintPair(\n        address _buyer,\n        address _seller,\n        address _longPositionAddress,\n        address _shortPositionAddress,\n        uint256 _amount\n    ) external;\n\n    function burn(\n        address _positionOwner,\n        address _positionAddress,\n        uint256 _amount\n    ) external;\n\n    function burnPair(\n        address _positionOwner,\n        address _longPositionAddress,\n        address _shortPositionAddress,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/ISyntheticAggregator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\nimport \"../libs/LibDerivative.sol\";\n\ninterface ISyntheticAggregator {\n    struct SyntheticCache {\n        uint256 buyerMargin;\n        uint256 sellerMargin;\n        uint256 authorCommission;\n        address authorAddress;\n        bool init;\n    }\n\n    function initialize(address _registry) external;\n\n    function getOrCacheSyntheticCache(bytes32 _derivativeHash, LibDerivative.Derivative calldata _derivative)\n        external\n        returns (SyntheticCache memory);\n\n    function getOrCacheMargin(bytes32 _derivativeHash, LibDerivative.Derivative calldata _derivative)\n        external\n        returns (uint256 buyerMargin, uint256 sellerMargin);\n}\n"
    },
    "contracts/interfaces/ITokenSpender.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ITokenSpender {\n    function claimTokens(\n        IERC20Upgradeable _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/ICore.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../core/registry/RegistryEntities.sol\";\nimport \"../libs/LibDerivative.sol\";\n\ninterface ICore {\n    function initialize(address _governor) external;\n\n    function getProtocolParametersArgs() external view returns (RegistryEntities.ProtocolParametersArgs memory);\n\n    function getProtocolAddresses() external view returns (RegistryEntities.ProtocolAddressesArgs memory);\n\n    function getReservesVaultBalance(address _reseveRecipient, address _token) external view returns (uint256);\n\n    function getDerivativePayouts(bytes32 _derivativeHash) external view returns (uint256[2] memory);\n\n    function getP2pDerivativeVaultFunds(bytes32 _derivativeHash) external view returns (uint256);\n\n    function isDerivativeCancelled(bytes32 _derivativeHash) external view returns (bool);\n\n    function updateProtocolParametersArgs() external;\n\n    function updateProtocolAddresses() external;\n\n    function claimReserves(address _tokenAddress) external;\n\n    function claimReserves(address _tokenAddress, uint256 _amount) external;\n\n    function create(\n        LibDerivative.Derivative calldata _derivative,\n        uint256 _amount,\n        address[2] calldata _positionsOwners\n    ) external;\n\n    function createAndMint(\n        LibDerivative.Derivative calldata _derivative,\n        uint256 _amount,\n        address[2] calldata _positionsOwners,\n        string calldata _derivativeAuthorCustomName\n    ) external;\n\n    function mint(\n        uint256 _amount,\n        address[2] calldata _positionsAddresses,\n        address[2] calldata _positionsOwners\n    ) external;\n\n    function execute(address _positionAddress, uint256 _amount) external;\n\n    function execute(\n        address _positionOwner,\n        address _positionAddress,\n        uint256 _amount\n    ) external;\n\n    function execute(address[] calldata _positionsAddresses, uint256[] calldata _amounts) external;\n\n    function execute(\n        address _positionsOwner,\n        address[] calldata _positionsAddresses,\n        uint256[] calldata _amounts\n    ) external;\n\n    function redeem(address[2] calldata _positionsAddresses, uint256 _amount) external;\n\n    function redeem(address[2][] calldata _positionsAddresses, uint256[] calldata _amounts) external;\n\n    function cancel(address _positionAddress, uint256 _amount) external;\n\n    function cancel(address[] calldata _positionsAddresses, uint256[] calldata _amounts) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/libs/LibDerivative.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\n/// @title Opium.Lib.LibDerivative contract should be inherited by contracts that use Derivative structure and calculate derivativeHash\nlibrary LibDerivative {\n    enum PositionType {\n        SHORT,\n        LONG\n    }\n\n    // Opium derivative structure (ticker) definition\n    struct Derivative {\n        // Margin parameter for syntheticId\n        uint256 margin;\n        // Maturity of derivative\n        uint256 endTime;\n        // Additional parameters for syntheticId\n        uint256[] params;\n        // oracleId of derivative\n        address oracleId;\n        // Margin token address of derivative\n        address token;\n        // syntheticId of derivative\n        address syntheticId;\n    }\n\n    /// @notice Calculates hash of provided Derivative\n    /// @param _derivative Derivative Instance of derivative to hash\n    /// @return derivativeHash bytes32 Derivative hash\n    function getDerivativeHash(Derivative memory _derivative) internal pure returns (bytes32 derivativeHash) {\n        derivativeHash = keccak256(\n            abi.encodePacked(\n                _derivative.margin,\n                _derivative.endTime,\n                _derivative.params,\n                _derivative.oracleId,\n                _derivative.token,\n                _derivative.syntheticId\n            )\n        );\n    }\n}\n"
    },
    "contracts/test/upgradeability/TestRegistryUpgrade.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../../core/registry/Registry.sol\";\n\ncontract TestRegistryUpgrade is Registry {\n    function placeholder() external pure returns (string memory) {\n        return \"upgraded\";\n    }\n}\n"
    },
    "contracts/test/e2e/OptionController.sol": {
      "content": "pragma solidity 0.8.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../../core/registry/RegistryEntities.sol\";\nimport \"../../interfaces/IRegistry.sol\";\nimport \"../../interfaces/ICore.sol\";\nimport \"../../interfaces/IOpiumProxyFactory.sol\";\nimport \"../../interfaces/ISyntheticAggregator.sol\";\nimport \"../../interfaces/ITokenSpender.sol\";\nimport \"../../libs/LibDerivative.sol\";\nimport \"../../libs/LibPosition.sol\";\nimport \"../../libs/LibCalculator.sol\";\n\ncontract OptionController is Ownable {\n    using SafeERC20 for IERC20;\n    using LibDerivative for LibDerivative.Derivative;\n    using LibPosition for bytes32;\n    using LibCalculator for uint256;\n\n    LibDerivative.Derivative private _derivative;\n    RegistryEntities.ProtocolAddressesArgs private _protocolAddressesArgs;\n    IRegistry private _registry;\n\n    /// @param registry_ address of the current Opium.Registry contract \n    constructor(address registry_) {\n        _registry = IRegistry(registry_);\n        _protocolAddressesArgs = IRegistry(_registry).getProtocolAddresses();\n    }\n\n    /// @notice See `_getPositionAddress`\n    function getPositionAddress(bool _isLong) external view returns (address) {\n        return _getPositionAddress(_isLong);\n    }\n\n    /// @notice See `_getMarginRequirement`\n    function getMarginRequirement(\n        uint256 _buyerMargin,\n        uint256 _sellerMargin,\n        uint256 _amount\n    ) external pure returns (uint256) {\n        return _getMarginRequirement(_buyerMargin, _sellerMargin, _amount);\n    }\n\n    /// @notice getter for the contract's underlying `LibDerivative.Derivative _derivative`\n    function getDerivative() external view returns (LibDerivative.Derivative memory) {\n        return _derivative;\n    }\n\n    /// @notice Helper to set this contract's underlying derivative recipe\n    /// @param derivative_ LibDerivative.Derivative derivative schema of the underlying synthetics\n    function setDerivative(LibDerivative.Derivative calldata derivative_) external onlyOwner {\n        _derivative = derivative_;\n    }\n\n    /// @notice Wrapper around `Opium.Core.create` to mint a derivative position contract\n    /// @param _amount uint256 Amount of derivative positions to be created\n    function create(uint256 _amount) external {\n        (uint256 buyerMargin, uint256 sellerMargin) = ISyntheticAggregator(_protocolAddressesArgs.syntheticAggregator).getOrCacheMargin(\n            _derivative.getDerivativeHash(),\n            _derivative\n        );\n        uint256 requiredMargin = _getMarginRequirement(buyerMargin, sellerMargin, _amount);\n\n        IERC20(_derivative.token).safeTransferFrom(msg.sender, address(this), requiredMargin);\n        IERC20(_derivative.token).approve(address(_protocolAddressesArgs.tokenSpender), 0);\n        IERC20(_derivative.token).approve(address(_protocolAddressesArgs.tokenSpender), requiredMargin);\n\n        ICore(_protocolAddressesArgs.core).create(_derivative, _amount, [msg.sender, msg.sender]);\n    }\n\n    /// @notice Wrapper around `Opium.Core.execute` to execute a derivative LONG position\n    /// @param _amount uint256 amount of SHORT positions to be executed\n    function executeShort(uint256 _amount) external {\n        address shortAddress = _getPositionAddress(false);\n        ICore(_protocolAddressesArgs.core).execute(msg.sender, shortAddress, _amount);\n    }\n\n    /// @notice Wrapper around `Opium.Core.execute` to execute a derivative LONG position\n    /// @param _amount uint256 amount of LONG positions to be executed\n    function executeLong(uint256 _amount) external {\n        address longAddress = _getPositionAddress(true);\n        ICore(_protocolAddressesArgs.core).execute(msg.sender, longAddress, _amount);\n    }\n\n    /// @notice Helper that wraps around `LibCalculator.mulWithPrecisionFactor` to compute the collateral require requirements to mint new LONG/SHORT positions of a derivative\n    /// @param _buyerMargin uint256 amount of required collateral to mint a single LONG position\n    /// @param _sellerMargin uint256 amount of required collateral to mint a single SHORT position\n    /// @param _amount uint256 amount of LONG/SHORT positions to be minted\n    function _getMarginRequirement(\n        uint256 _buyerMargin,\n        uint256 _sellerMargin,\n        uint256 _amount\n    ) private pure returns (uint256) {\n        return (_buyerMargin + _sellerMargin).mulWithPrecisionFactor(_amount);\n    }\n\n    /// @notice Wrapper around `LibPosition.predictDeterministicAddress` to compute the create2 address of a derivative position contract based on its derivativeHash as a salt\n    /// @param _isLong bool true if the derivative position contract to be calculated is a LONG position, false if it is a SHORT position\n    function _getPositionAddress(bool _isLong) private view returns (address) {\n        bytes32 derivativeHash = _derivative.getDerivativeHash();\n        address positionAddress = derivativeHash.predictDeterministicAddress(\n            _isLong,\n            IOpiumProxyFactory(_protocolAddressesArgs.opiumProxyFactory).getImplementationAddress(),\n            address(_protocolAddressesArgs.opiumProxyFactory)\n        );\n        return positionAddress;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/libs/LibPosition.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nlibrary LibPosition {\n    function predictDeterministicAddress(\n        bytes32 _derivativeHash,\n        bool _isLong,\n        address _positionImplementationAddress,\n        address _factoryAddress\n    ) internal pure returns (address) {\n        return _predictDeterministicAddress(_derivativeHash, _isLong, _positionImplementationAddress, _factoryAddress);\n    }\n\n    function predictAndCheckDeterministicAddress(\n        bytes32 _derivativeHash,\n        bool _isLong,\n        address _positionImplementationAddress,\n        address _factoryAddress\n    ) internal view returns (address, bool) {\n        address predicted = _predictDeterministicAddress(\n            _derivativeHash,\n            _isLong,\n            _positionImplementationAddress,\n            _factoryAddress\n        );\n        bool isDeployed = _isContract(predicted);\n        return (predicted, isDeployed);\n    }\n\n    function deployOpiumPosition(\n        bytes32 _derivativeHash,\n        bool _isLong,\n        address _positionImplementationAddress\n    ) internal returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(_derivativeHash, _isLong ? \"L\" : \"S\"));\n        return ClonesUpgradeable.cloneDeterministic(_positionImplementationAddress, salt);\n    }\n\n    function _predictDeterministicAddress(\n        bytes32 _derivativeHash,\n        bool _isLong,\n        address _positionImplementationAddress,\n        address _factoryAddress\n    ) private pure returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(_derivativeHash, _isLong ? \"L\" : \"S\"));\n        return ClonesUpgradeable.predictDeterministicAddress(_positionImplementationAddress, salt, _factoryAddress);\n    }\n\n    /// @notice checks whether a contract has already been deployed at a specific address\n    /// @return bool true if a contract has been deployed at a specific address and false otherwise\n    function _isContract(address _address) private view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_address)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/core/Core.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./registry/RegistryEntities.sol\";\nimport \"./base/RegistryManager.sol\";\nimport \"../libs/LibDerivative.sol\";\nimport \"../libs/LibPosition.sol\";\nimport \"../libs/LibCalculator.sol\";\nimport \"../interfaces/IOpiumProxyFactory.sol\";\nimport \"../interfaces/ISyntheticAggregator.sol\";\nimport \"../interfaces/IOracleAggregator.sol\";\nimport \"../interfaces/ITokenSpender.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"../interfaces/IOpiumPositionToken.sol\";\nimport \"../interfaces/IDerivativeLogic.sol\";\n\n/**\n    Error codes:\n    - C1 = ERROR_CORE_POSITION_ADDRESSES_AND_AMOUNTS_DO_NOT_MATCH\n    - C2 = ERROR_CORE_WRONG_HASH\n    - C3 = ERROR_CORE_WRONG_POSITION_TYPE\n    - C4 = ERROR_CORE_NOT_ENOUGH_POSITIONS\n    - C5 = ERROR_CORE_WRONG_MOD\n    - C6 = ERROR_CORE_CANT_CANCEL_DUMMY_ORACLE_ID\n    - C7 = ERROR_CORE_TICKER_WAS_CANCELLED\n    - C8 = ERROR_CORE_SYNTHETIC_VALIDATION_ERROR\n    - C9 = ERROR_CORE_INSUFFICIENT_P2P_BALANCE\n    - C10 = ERROR_CORE_EXECUTION_BEFORE_MATURITY_NOT_ALLOWED\n    - C11 = ERROR_CORE_SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED\n    - C12 = ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE\n    - C13 = ERROR_CORE_CANCELLATION_IS_NOT_ALLOWED\n    - C14 = ERROR_CORE_NOT_OPIUM_FACTORY_POSITIONS\n    - C15 = ERROR_CORE_RESERVE_AMOUNT_GREATER_THAN_BALANCE\n    - C16 = ERROR_CORE_NO_DERIVATIVE_CREATION_IN_THE_PAST\n    - C17 = ERROR_CORE_PROTOCOL_POSITION_CREATION_PAUSED\n    - C18 = ERROR_CORE_PROTOCOL_POSITION_MINT_PAUSED\n    - C19 = ERROR_CORE_PROTOCOL_POSITION_REDEMPTION_PAUSED\n    - C20 = ERROR_CORE_PROTOCOL_POSITION_EXECUTION_PAUSED\n    - C21 = ERROR_CORE_PROTOCOL_POSITION_CANCELLATION_PAUSED\n    - C22 = ERROR_CORE_PROTOCOL_RESERVE_CLAIM_PAUSED\n    - C23 = ERROR_CORE_MISMATCHING_DERIVATIVES\n */\n\n/// @title Opium.Core contract creates positions, holds and distributes margin at the maturity\ncontract Core is ReentrancyGuardUpgradeable, RegistryManager {\n    using LibDerivative for LibDerivative.Derivative;\n    using LibCalculator for uint256;\n    using LibPosition for bytes32;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Emitted when Core creates a new LONG/SHORT position pair\n    event LogCreated(address indexed _buyer, address indexed _seller, bytes32 indexed _derivativeHash, uint256 _amount);\n    // Emitted when Core mints an amount of LONG/SHORT positions\n    event LogMinted(address indexed _buyer, address indexed _seller, bytes32 indexed _derivativeHash, uint256 _amount);\n    // Emitted when Core executes positions\n    event LogExecuted(address indexed _positionsOwner, address indexed _positionAddress, uint256 _amount);\n    // Emitted when Core cancels ticker for the first time\n    event LogDerivativeHashCancelled(address indexed _positionOwner, bytes32 indexed _derivativeHash);\n    // Emitted when Core cancels a position of a previously cancelled Derivative.derivativeHash\n    event LogCancelled(address indexed _positionOwner, bytes32 indexed _derivativeHash, uint256 _amount);\n    // Emitted when Core redeems an amount of market neutral positions\n    event LogRedeemed(address indexed _positionOwner, bytes32 indexed _derivativeHash, uint256 _amount);\n\n    RegistryEntities.ProtocolParametersArgs private protocolParametersArgs;\n    RegistryEntities.ProtocolAddressesArgs private protocolAddressesArgs;\n\n    // Key-value entity that maps a derivativeHash representing an existing derivative to its available balance (i.e: the amount of collateral that has not been claimed yet)\n    mapping(bytes32 => uint256) private p2pVaults;\n\n    // Key-value entity that maps a derivativeHash representing an existing derivative to a boolean representing whether a given derivative has been cancelled\n    mapping(bytes32 => bool) private cancelledDerivatives;\n\n    /// Key-value entity that maps a derivativeHash representing an existing derivative to its respective buyer's and seller's payouts.\n    /// Both the buyer's and seller's are cached when a derivative's position is successfully executed for the first time\n    /// derivativePayouts[derivativeHash][0] => buyer's payout\n    /// derivativePayouts[derivativeHash][1] => seller's payout\n    mapping(bytes32 => uint256[2]) private derivativePayouts;\n\n    /// Reseves vault\n    /// Key-value entity that maps an address representing a reserve recipient to a token address and the balance associated to the token address. It keeps tracks of the balances of reserve recipients (i.e: derivative authors)\n    mapping(address => mapping(address => uint256)) private reservesVault;\n\n    /// @notice It is called only once upon deployment of the contract. It sets the current Opium.Registry address and assigns the current protocol parameters stored in the Opium.Registry to the Core.protocolParametersArgs private variable {see RegistryEntities.sol for a description of the ProtocolParametersArgs struct}\n    function initialize(address _registry) external initializer {\n        __RegistryManager__init(_registry);\n        __ReentrancyGuard_init();\n        protocolParametersArgs = IRegistry(_registry).getProtocolParameters();\n    }\n\n    // ****************** EXTERNAL FUNCTIONS ******************\n\n    // ***** GETTERS *****\n\n    /// @notice It returns Opium.Core's internal state of the protocol parameters fetched from the Opium.Registry\n    /// @dev {see RegistryEntities.sol for a description of the ProtocolParametersArgs struct}\n    /// @return ProtocolParametersArgs struct including the protocol's main parameters\n    function getProtocolParametersArgs() external view returns (RegistryEntities.ProtocolParametersArgs memory) {\n        return protocolParametersArgs;\n    }\n\n    /// @notice It returns Opium.Core's internal state of the protocol contracts' and recipients' addresses fetched from the Opium.Registry\n    /// @dev {see RegistryEntities.sol for a description of the protocolAddressesArgs struct}\n    /// @return ProtocolAddressesArgs struct including the protocol's main addresses - contracts and reseves recipients\n    function getProtocolAddresses() external view returns (RegistryEntities.ProtocolAddressesArgs memory) {\n        return protocolAddressesArgs;\n    }\n\n    /// @notice It returns the accrued reseves of a given address denominated in a specified token\n    /// @param _reseveRecipient address of the reseve recipient\n    /// @param _token address of a token used as a reseve compensation\n    /// @return uint256 amount of the accrued reseves denominated in the provided token\n    function getReservesVaultBalance(address _reseveRecipient, address _token) external view returns (uint256) {\n        return reservesVault[_reseveRecipient][_token];\n    }\n\n    /// @notice It queries the buyer's and seller's payouts for a given derivative\n    /// @notice if it returns [0, 0] then the derivative has not been executed yet\n    /// @param _derivativeHash bytes32 unique derivative identifier\n    /// @return uint256[2] tuple containing LONG and SHORT payouts\n    function getDerivativePayouts(bytes32 _derivativeHash) external view returns (uint256[2] memory) {\n        return derivativePayouts[_derivativeHash];\n    }\n\n    /// @notice It queries the amount of funds allocated for a given derivative\n    /// @param _derivativeHash bytes32 unique derivative identifier\n    /// @return uint256 representing the remaining derivative's funds\n    function getP2pDerivativeVaultFunds(bytes32 _derivativeHash) external view returns (uint256) {\n        return p2pVaults[_derivativeHash];\n    }\n\n    /// @notice It checks whether a given derivative has been cancelled\n    /// @param _derivativeHash bytes32 unique derivative identifier\n    /// @return bool true if derivative has been cancelled, false if derivative has not been cancelled\n    function isDerivativeCancelled(bytes32 _derivativeHash) external view returns (bool) {\n        return cancelledDerivatives[_derivativeHash];\n    }\n\n    // ***** SETTERS *****\n\n    /// @notice It allows to update the Opium Protocol parameters according to the current state of the Opium.Registry\n    /// @dev {see RegistryEntities.sol for a description of the ProtocolParametersArgs struct}\n    /// @dev should be called immediately after the deployment of the contract\n    /// @dev only accounts who have been assigned the CORE_CONFIGURATION_UPDATER_ROLE { See LibRoles.sol } should be able to call the function\n    function updateProtocolParametersArgs() external onlyCoreConfigurationUpdater {\n        protocolParametersArgs = registry.getProtocolParameters();\n    }\n\n    /// @notice Allows to sync the Core protocol's addresses with the Registry protocol's addresses in case the registry updates at least one of them\n    /// @dev {see RegistryEntities.sol for a description of the protocolAddressesArgs struct}\n    /// @dev should be called immediately after the deployment of the contract\n    /// @dev only accounts who have been assigned the CORE_CONFIGURATION_UPDATER_ROLE { See LibRoles.sol } should be able to call the function\n    function updateProtocolAddresses() external onlyCoreConfigurationUpdater {\n        protocolAddressesArgs = registry.getProtocolAddresses();\n    }\n\n    /// @notice It allows a reseve recipient to claim their entire accrued reserves\n    /// @param _tokenAddress address of the ERC20 token to withdraw\n    function claimReserves(address _tokenAddress) external nonReentrant {\n        require(!registry.isProtocolReserveClaimPaused(), \"C22\");\n        uint256 balance = reservesVault[msg.sender][_tokenAddress];\n        reservesVault[msg.sender][_tokenAddress] = 0;\n        IERC20Upgradeable(_tokenAddress).safeTransfer(msg.sender, balance);\n    }\n\n    /// @notice It allows a reserves recipient to to claim the desired amount of accrued reserves\n    /// @param _tokenAddress address of the ERC20 token to withdraw\n    /// @param _amount uint256 amount of reserves to withdraw\n    function claimReserves(address _tokenAddress, uint256 _amount) external nonReentrant {\n        require(!registry.isProtocolReserveClaimPaused(), \"C22\");\n        uint256 balance = reservesVault[msg.sender][_tokenAddress];\n        require(balance >= _amount, \"C15\");\n        reservesVault[msg.sender][_tokenAddress] -= _amount;\n        IERC20Upgradeable(_tokenAddress).safeTransfer(msg.sender, _amount);\n    }\n\n    /// @notice It deploys and mints the two erc20 contracts representing a derivative's LONG and SHORT positions { see Core._create for the business logic description }\n    /// @param _derivative LibDerivative.Derivative Derivative definition\n    /// @param _amount uint256 Amount of positions to create\n    /// @param _positionsOwners address[2] Addresses of buyer and seller\n    /// [0] - buyer address\n    /// [1] - seller address\n    function create(\n        LibDerivative.Derivative calldata _derivative,\n        uint256 _amount,\n        address[2] calldata _positionsOwners\n    ) external nonReentrant {\n        _create(_derivative, _derivative.getDerivativeHash(), _amount, _positionsOwners);\n    }\n\n    /// @notice It can either 1) deploy AND mint 2) only mint.\n    /// @notice It checks whether the ERC20 contracts representing the LONG and SHORT positions of the provided `LibDerivative.Derivative` have been deployed. If not, then it deploys the respective ERC20 contracts and mints the supplied _amount respectively to the provided buyer's and seller's accounts. If they have already been deployed, it only mints the provided _amount to the provided buyer's and seller's accounts.\n    /// @dev if the position contracts have been deployed, it uses Core._create()\n    /// @dev if the position contracts have deployed, it uses Core._mint()\n    /// @param _derivative LibDerivative.Derivative Derivative definition\n    /// @param _amount uint256 Amount of LONG and SHORT positions create and/or mint\n    /// @param _positionsOwners address[2] Addresses of buyer and seller\n    /// _positionsOwners[0] - buyer address -> receives LONG position\n    /// _positionsOwners[1] - seller address -> receives SHORT position\n    function createAndMint(\n        LibDerivative.Derivative calldata _derivative,\n        uint256 _amount,\n        address[2] calldata _positionsOwners\n    ) external nonReentrant {\n        bytes32 derivativeHash = _derivative.getDerivativeHash();\n        address implementationAddress = IOpiumProxyFactory(protocolAddressesArgs.opiumProxyFactory)\n            .getImplementationAddress();\n        (address longPositionTokenAddress, bool isLongDeployed) = derivativeHash.predictAndCheckDeterministicAddress(\n            true,\n            implementationAddress,\n            address(protocolAddressesArgs.opiumProxyFactory)\n        );\n        (address shortPositionTokenAddress, bool isShortDeployed) = derivativeHash.predictAndCheckDeterministicAddress(\n            false,\n            implementationAddress,\n            protocolAddressesArgs.opiumProxyFactory\n        );\n        // both erc20 positions have not been deployed\n        require(isLongDeployed == isShortDeployed, \"C23\");\n        if (!isLongDeployed) {\n            _create(_derivative, derivativeHash, _amount, _positionsOwners);\n        } else {\n            _mint(_amount, [longPositionTokenAddress, shortPositionTokenAddress], _positionsOwners);\n        }\n    }\n\n    /// @notice This function mints the provided amount of LONG/SHORT positions to msg.sender for a previously deployed pair of LONG/SHORT ERC20 contracts { see Core._mint for the business logic description }\n    /// @param _amount uint256 Amount of positions to create\n    /// @param _positionsAddresses address[2] Addresses of buyer and seller\n    /// [0] - LONG erc20 position address\n    /// [1] - SHORT erc20 position address\n    /// @param _positionsOwners address[2] Addresses of buyer and seller\n    /// _positionsOwners[0] - buyer address\n    /// _positionsOwners[1] - seller address\n    function mint(\n        uint256 _amount,\n        address[2] calldata _positionsAddresses,\n        address[2] calldata _positionsOwners\n    ) external nonReentrant {\n        _mint(_amount, _positionsAddresses, _positionsOwners);\n    }\n\n    /// @notice Executes a single position of `msg.sender` with specified `positionAddress` { see Core._execute for the business logic description }\n    /// @param _positionAddress address `positionAddress` of position that needs to be executed\n    /// @param _amount uint256 Amount of positions to execute\n    function execute(address _positionAddress, uint256 _amount) external nonReentrant {\n        _execute(msg.sender, _positionAddress, _amount);\n    }\n\n    /// @notice Executes a single position of `_positionsOwner` with specified `positionAddress` { see Core._execute for the business logic description }\n    /// @param _positionOwner address Address of the owner of positions\n    /// @param _positionAddress address `positionAddress` of positions that needs to be executed\n    /// @param _amount uint256 Amount of positions to execute\n    function execute(\n        address _positionOwner,\n        address _positionAddress,\n        uint256 _amount\n    ) external nonReentrant {\n        _execute(_positionOwner, _positionAddress, _amount);\n    }\n\n    /// @notice Executes several positions of `msg.sender` with different `positionAddresses` { see Core._execute for the business logic description }\n    /// @param _positionsAddresses address[] `positionAddresses` of positions that need to be executed\n    /// @param _amounts uint256[] Amount of positions to execute for each `positionAddress`\n    function execute(address[] calldata _positionsAddresses, uint256[] calldata _amounts) external nonReentrant {\n        require(_positionsAddresses.length == _amounts.length, \"C1\");\n        for (uint256 i; i < _positionsAddresses.length; i++) {\n            _execute(msg.sender, _positionsAddresses[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Executes several positions of `_positionsOwner` with different `positionAddresses` { see Core._execute for the business logic description }\n    /// @param _positionsOwner address Address of the owner of positions\n    /// @param _positionsAddresses address[] `positionAddresses` of positions that need to be executed\n    /// @param _amounts uint256[] Amount of positions to execute for each `positionAddresses`\n    function execute(\n        address _positionsOwner,\n        address[] calldata _positionsAddresses,\n        uint256[] calldata _amounts\n    ) external nonReentrant {\n        require(_positionsAddresses.length == _amounts.length, \"C1\");\n        for (uint256 i; i < _positionsAddresses.length; i++) {\n            _execute(_positionsOwner, _positionsAddresses[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Redeems a single market neutral position pair { see Core._redeem for the business logic description }\n    /// @param _positionsAddresses address[2] `_positionsAddresses` of the positions that need to be redeemed\n    /// @param _amount uint256 Amount of tokens to redeem\n    function redeem(address[2] calldata _positionsAddresses, uint256 _amount) external nonReentrant {\n        _redeem(_positionsAddresses, _amount);\n    }\n\n    /// @notice Redeems several market neutral position pairs { see Core._redeem for the business logic description }\n    /// @param _positionsAddresses address[2][] `_positionsAddresses` of the positions that need to be redeemed\n    /// @param _amounts uint256[] Amount of tokens to redeem for each position pair\n    function redeem(address[2][] calldata _positionsAddresses, uint256[] calldata _amounts) external nonReentrant {\n        require(_positionsAddresses.length == _amounts.length, \"C1\");\n        for (uint256 i = 0; i < _positionsAddresses.length; i++) {\n            _redeem(_positionsAddresses[i], _amounts[i]);\n        }\n    }\n\n    /// @notice It cancels the specified amount of a derivative's position { see Core._cancel for the business logic description }\n    /// @param _positionAddress PositionType of positions to be canceled\n    /// @param _amount uint256 Amount of positions to cancel\n    function cancel(address _positionAddress, uint256 _amount) external nonReentrant {\n        _cancel(_positionAddress, _amount);\n    }\n\n    /// @notice It cancels the specified amounts of a list of derivative's position { see Core._cancel for the business logic description }\n    /// @param _positionsAddresses PositionTypes of positions to be cancelled\n    /// @param _amounts uint256[] Amount of positions to cancel for each `positionAddress`\n    function cancel(address[] calldata _positionsAddresses, uint256[] calldata _amounts) external nonReentrant {\n        require(_positionsAddresses.length == _amounts.length, \"C1\");\n        for (uint256 i; i < _positionsAddresses.length; i++) {\n            _cancel(_positionsAddresses[i], _amounts[i]);\n        }\n    }\n\n    // ****************** PRIVATE FUNCTIONS ******************\n\n    // ***** SETTERS *****\n\n    /// @notice It deploys two ERC20 contracts representing respectively the LONG and SHORT position of the provided `LibDerivative.Derivative` derivative and mints the provided amount of SHORT positions to a seller and LONG positions to a buyer\n    /// @dev it can only be called if the ERC20 contracts for the derivative's positions have not yet been deployed\n    /// @dev the uint256 _amount of positions to be minted can be 0 - which results in the deployment of the position contracts without any circulating supply\n    /// @param _derivative LibDerivative.Derivative Derivative definition\n    /// @param _derivativeHash unique identifier of a derivative which is used as a key in the p2pVaults mapping\n    /// @param _amount uint256 Amount of positions to create\n    /// @param _positionsOwners address[2] Addresses of buyer and seller\n    /// [0] - buyer address -> receives LONG position\n    /// [1] - seller address -> receives SHORT position\n    function _create(\n        LibDerivative.Derivative calldata _derivative,\n        bytes32 _derivativeHash,\n        uint256 _amount,\n        address[2] calldata _positionsOwners\n    ) private {\n        require(block.timestamp < _derivative.endTime, \"C16\");\n        require(!registry.isProtocolPositionCreationPaused(), \"C17\");\n\n        // Validate input data against Derivative logic (`syntheticId`)\n        require(IDerivativeLogic(_derivative.syntheticId).validateInput(_derivative), \"C8\");\n\n        uint256[2] memory margins;\n        // Get cached margin required according to logic from Opium.SyntheticAggregator\n        // margins[0] - buyerMargin\n        // margins[1] - sellerMargin\n        (margins[0], margins[1]) = ISyntheticAggregator(protocolAddressesArgs.syntheticAggregator).getOrCacheMargin(\n            _derivativeHash,\n            _derivative\n        );\n\n        uint256 totalMargin = margins[0] + margins[1];\n        require((totalMargin * _amount).modWithPrecisionFactor() == 0, \"C5\");\n        uint256 totalMarginToE18 = totalMargin.mulWithPrecisionFactor(_amount);\n\n        // Check ERC20 tokens allowance: (margins[0] + margins[1]) * amount\n        // `msg.sender` must provide margin for position creation\n        require(\n            IERC20Upgradeable(_derivative.token).allowance(msg.sender, protocolAddressesArgs.tokenSpender) >=\n                totalMarginToE18,\n            \"C12\"\n        );\n\n        // Increment p2p positions balance by collected margin: vault += (margins[0] + margins[1]) * _amount\n        _increaseP2PVault(_derivativeHash, totalMarginToE18);\n\n        // Take ERC20 tokens from msg.sender, should never revert in correct ERC20 implementation\n        ITokenSpender(protocolAddressesArgs.tokenSpender).claimTokens(\n            IERC20Upgradeable(_derivative.token),\n            msg.sender,\n            address(this),\n            totalMarginToE18\n        );\n\n        // Mint LONG and SHORT positions tokens\n        IOpiumProxyFactory(protocolAddressesArgs.opiumProxyFactory).create(\n            _positionsOwners[0],\n            _positionsOwners[1],\n            _amount,\n            _derivativeHash,\n            _derivative\n        );\n\n        emit LogCreated(_positionsOwners[0], _positionsOwners[1], _derivativeHash, _amount);\n    }\n\n    /// @notice It mints the provided amount of LONG and SHORT positions of a given derivative and it forwards them to the provided positions' owners\n    /// @dev it can only be called if the ERC20 contracts for the derivative's positions have already been deployed\n    /// @dev the uint256 _amount of positions to be minted can be 0\n    /// @param _amount uint256 Amount of LONG and SHORT positions to mint\n    /// @param _positionsAddresses address[2] tuple containing the addresses of the derivative's positions to be minted\n    /// _positionsAddresses[0] -> erc20-based LONG position\n    /// _positionsAddresses[1] - erc20-based SHORT position\n    /// @param _positionsOwners address[2] Addresses of buyer and seller\n    /// [0] - buyer address -> receives LONG position\n    /// [1] - seller address -> receives SHORT position\n    function _mint(\n        uint256 _amount,\n        address[2] memory _positionsAddresses,\n        address[2] memory _positionsOwners\n    ) private {\n        require(!registry.isProtocolPositionMintingPaused(), \"C18\");\n        IOpiumPositionToken.OpiumPositionTokenParams memory longOpiumPositionTokenParams = IOpiumPositionToken(\n            _positionsAddresses[0]\n        ).getPositionTokenData();\n        IOpiumPositionToken.OpiumPositionTokenParams memory shortOpiumPositionTokenParams = IOpiumPositionToken(\n            _positionsAddresses[1]\n        ).getPositionTokenData();\n        _onlyOpiumFactoryTokens(_positionsAddresses[0], longOpiumPositionTokenParams);\n        _onlyOpiumFactoryTokens(_positionsAddresses[1], shortOpiumPositionTokenParams);\n        require(shortOpiumPositionTokenParams.derivativeHash == longOpiumPositionTokenParams.derivativeHash, \"C2\");\n        require(longOpiumPositionTokenParams.positionType == LibDerivative.PositionType.LONG, \"C3\");\n        require(shortOpiumPositionTokenParams.positionType == LibDerivative.PositionType.SHORT, \"C3\");\n\n        require(block.timestamp < longOpiumPositionTokenParams.derivative.endTime, \"C16\");\n\n        uint256[2] memory margins;\n        // Get cached margin required according to logic from Opium.SyntheticAggregator\n        // margins[0] - buyerMargin\n        // margins[1] - sellerMargin\n        (margins[0], margins[1]) = ISyntheticAggregator(protocolAddressesArgs.syntheticAggregator).getOrCacheMargin(\n            longOpiumPositionTokenParams.derivativeHash,\n            longOpiumPositionTokenParams.derivative\n        );\n\n        uint256 totalMargin = margins[0] + margins[1];\n        require((totalMargin * _amount).modWithPrecisionFactor() == 0, \"C5\");\n        uint256 totalMarginToE18 = totalMargin.mulWithPrecisionFactor(_amount);\n\n        // Check ERC20 tokens allowance: (margins[0] + margins[1]) * amount\n        // `msg.sender` must provide margin for position creation\n        require(\n            IERC20Upgradeable(longOpiumPositionTokenParams.derivative.token).allowance(\n                msg.sender,\n                protocolAddressesArgs.tokenSpender\n            ) >= totalMarginToE18,\n            \"C12\"\n        );\n\n        // Increment p2p positions balance by collected margin: vault += (margins[0] + margins[1]) * _amount\n        _increaseP2PVault(longOpiumPositionTokenParams.derivativeHash, totalMarginToE18);\n\n        // Take ERC20 tokens from msg.sender, should never revert in correct ERC20 implementation\n        ITokenSpender(protocolAddressesArgs.tokenSpender).claimTokens(\n            IERC20Upgradeable(longOpiumPositionTokenParams.derivative.token),\n            msg.sender,\n            address(this),\n            totalMarginToE18\n        );\n\n        // Mint LONG and SHORT positions tokens\n        IOpiumProxyFactory(protocolAddressesArgs.opiumProxyFactory).mintPair(\n            _positionsOwners[0],\n            _positionsOwners[1],\n            _positionsAddresses[0],\n            _positionsAddresses[1],\n            _amount\n        );\n\n        emit LogMinted(_positionsOwners[0], _positionsOwners[1], longOpiumPositionTokenParams.derivativeHash, _amount);\n    }\n\n    /// @notice It redeems the provided amount of a derivative's market neutral position pair (LONG/SHORT) owned by the msg.sender - redeeming a market neutral position pair results in an equal amount of LONG and SHORT positions being burned in exchange for their original collateral\n    /// @param _positionsAddresses address[2] `positionAddresses` representing the tuple of market-neutral positions ordered in the following way:\n    /// [0] LONG position\n    /// [1] SHORT position\n    /// @param _amount uint256 amount of the LONG and SHORT positions to be redeemed\n    function _redeem(address[2] memory _positionsAddresses, uint256 _amount) private {\n        require(!registry.isProtocolPositionRedemptionPaused(), \"C19\");\n        IOpiumPositionToken.OpiumPositionTokenParams memory longOpiumPositionTokenParams = IOpiumPositionToken(\n            _positionsAddresses[0]\n        ).getPositionTokenData();\n        IOpiumPositionToken.OpiumPositionTokenParams memory shortOpiumPositionTokenParams = IOpiumPositionToken(\n            _positionsAddresses[1]\n        ).getPositionTokenData();\n        _onlyOpiumFactoryTokens(_positionsAddresses[0], longOpiumPositionTokenParams);\n        _onlyOpiumFactoryTokens(_positionsAddresses[1], shortOpiumPositionTokenParams);\n        require(shortOpiumPositionTokenParams.derivativeHash == longOpiumPositionTokenParams.derivativeHash, \"C2\");\n        require(longOpiumPositionTokenParams.positionType == LibDerivative.PositionType.LONG, \"C3\");\n        require(shortOpiumPositionTokenParams.positionType == LibDerivative.PositionType.SHORT, \"C3\");\n\n        ISyntheticAggregator.SyntheticCache memory syntheticCache = ISyntheticAggregator(\n            protocolAddressesArgs.syntheticAggregator\n        ).getOrCacheSyntheticCache(\n                shortOpiumPositionTokenParams.derivativeHash,\n                shortOpiumPositionTokenParams.derivative\n            );\n\n        uint256 totalMargin = (syntheticCache.buyerMargin + syntheticCache.sellerMargin).mulWithPrecisionFactor(\n            _amount\n        );\n        uint256 reserves = _computeReserves(\n            syntheticCache.authorAddress,\n            shortOpiumPositionTokenParams.derivative.token,\n            protocolAddressesArgs.protocolRedemptionReserveClaimer,\n            protocolParametersArgs.derivativeAuthorRedemptionReservePart,\n            protocolParametersArgs.protocolRedemptionReservePart,\n            totalMargin\n        );\n\n        _decreaseP2PVault(shortOpiumPositionTokenParams.derivativeHash, totalMargin);\n\n        IOpiumProxyFactory(protocolAddressesArgs.opiumProxyFactory).burnPair(\n            msg.sender,\n            _positionsAddresses[0],\n            _positionsAddresses[1],\n            _amount\n        );\n\n        IERC20Upgradeable(shortOpiumPositionTokenParams.derivative.token).safeTransfer(\n            msg.sender,\n            totalMargin - reserves\n        );\n\n        emit LogRedeemed(msg.sender, shortOpiumPositionTokenParams.derivativeHash, _amount);\n    }\n\n    /// @notice It executes the provided amount of a derivative's position owned by a given position's owner - which results in the distribution of the position's payout and related reseves if the position is profitable and in the executed position's amount being burned regardless of its profitability\n    /// @param _positionOwner address Address of the owner of positions\n    /// @param _positionAddress address `_positionAddress` of the ERC20 OpiumPositionToken that needs to be executed\n    /// @param _amount uint256 Amount of position to execute for the provided `positionAddress`\n    function _execute(\n        address _positionOwner,\n        address _positionAddress,\n        uint256 _amount\n    ) private {\n        require(!registry.isProtocolPositionExecutionPaused(), \"C20\");\n        IOpiumPositionToken.OpiumPositionTokenParams memory opiumPositionTokenParams = IOpiumPositionToken(\n            _positionAddress\n        ).getPositionTokenData();\n        _onlyOpiumFactoryTokens(_positionAddress, opiumPositionTokenParams);\n        // Check if ticker was canceled\n        require(!cancelledDerivatives[opiumPositionTokenParams.derivativeHash], \"C7\");\n        // Check if execution is performed at a timestamp greater than or equal to the maturity date of the derivative\n        require(block.timestamp >= opiumPositionTokenParams.derivative.endTime, \"C10\");\n\n        // Checking whether execution is performed by `_positionsOwner` or `_positionsOwner` allowed third party executions on its behalf\n        require(\n            _positionOwner == msg.sender ||\n                IDerivativeLogic(opiumPositionTokenParams.derivative.syntheticId).thirdpartyExecutionAllowed(\n                    _positionOwner\n                ),\n            \"C11\"\n        );\n\n        // Burn executed position tokens\n        IOpiumProxyFactory(protocolAddressesArgs.opiumProxyFactory).burn(_positionOwner, _positionAddress, _amount);\n\n        // Returns payout for all positions\n        uint256 payout = _computePayout(\n            opiumPositionTokenParams,\n            _amount,\n            ISyntheticAggregator(protocolAddressesArgs.syntheticAggregator),\n            IOracleAggregator(protocolAddressesArgs.oracleAggregator)\n        );\n\n        // Transfer payout\n        if (payout > 0) {\n            IERC20Upgradeable(opiumPositionTokenParams.derivative.token).safeTransfer(_positionOwner, payout);\n        }\n\n        emit LogExecuted(_positionOwner, _positionAddress, _amount);\n    }\n\n    /// @notice Cancels tickers, burns positions and returns margins to the position owner in case no data were provided within `protocolParametersArgs.noDataCancellationPeriod`\n    /// @param _positionAddress PositionTypes of positions to be canceled\n    /// @param _amount uint256[] Amount of positions to cancel for each `positionAddress`\n    function _cancel(address _positionAddress, uint256 _amount) private {\n        require(!registry.isProtocolPositionCancellationPaused(), \"C21\");\n        IOpiumPositionToken.OpiumPositionTokenParams memory opiumPositionTokenParams = IOpiumPositionToken(\n            _positionAddress\n        ).getPositionTokenData();\n        _onlyOpiumFactoryTokens(_positionAddress, opiumPositionTokenParams);\n\n        // It's sufficient to perform all the sanity checks only if a derivative has not yet been canceled\n        if (!cancelledDerivatives[opiumPositionTokenParams.derivativeHash]) {\n            // Don't allow to cancel tickers with \"dummy\" oracleIds\n            require(opiumPositionTokenParams.derivative.oracleId != address(0), \"C6\");\n\n            // Check if cancellation is called after `protocolParametersArgs.noDataCancellationPeriod` and `oracleId` didn't provide the required data\n            require(\n                opiumPositionTokenParams.derivative.endTime + protocolParametersArgs.noDataCancellationPeriod <=\n                    block.timestamp,\n                \"C13\"\n            );\n            // Ensures that `Opium.OracleAggregator` has still not been provided with data after noDataCancellationperiod\n            // The check needs to be performed only the first time a derivative is being canceled as to avoid preventing other parties from canceling their positions in case `Opium.OracleAggregator` receives data after the successful cancelation\n            require(\n                !IOracleAggregator(protocolAddressesArgs.oracleAggregator).hasData(\n                    opiumPositionTokenParams.derivative.oracleId,\n                    opiumPositionTokenParams.derivative.endTime\n                ),\n                \"C13\"\n            );\n            cancelledDerivatives[opiumPositionTokenParams.derivativeHash] = true;\n            // Emit `LogDerivativeHashCancelled` event only once and mark ticker as canceled\n            emit LogDerivativeHashCancelled(msg.sender, opiumPositionTokenParams.derivativeHash);\n        }\n\n        uint256 payout;\n        // Check if `_positionsAddresses` is a LONG position\n        if (opiumPositionTokenParams.positionType == LibDerivative.PositionType.LONG) {\n            // Get cached margin required according to logic from Opium.SyntheticAggregator\n            // (buyerMargin, sellerMargin) = syntheticAggregator.getMargin\n            (uint256 buyerMargin, ) = ISyntheticAggregator(protocolAddressesArgs.syntheticAggregator).getOrCacheMargin(\n                opiumPositionTokenParams.derivativeHash,\n                opiumPositionTokenParams.derivative\n            );\n            // Set payout to buyerPayout\n            payout = buyerMargin.mulWithPrecisionFactor(_amount);\n\n            // Check if `positionAddress` is a SHORT position\n        } else {\n            // Get cached margin required according to logic from Opium.SyntheticAggregator\n            // (buyerMargin, sellerMargin) = syntheticAggregator.getMargin\n            (, uint256 sellerMargin) = ISyntheticAggregator(protocolAddressesArgs.syntheticAggregator).getOrCacheMargin(\n                opiumPositionTokenParams.derivativeHash,\n                opiumPositionTokenParams.derivative\n            );\n            // Set payout to sellerPayout\n            payout = sellerMargin.mulWithPrecisionFactor(_amount);\n        }\n\n        _decreaseP2PVault(opiumPositionTokenParams.derivativeHash, payout);\n\n        // Burn cancelled position tokens\n        IOpiumProxyFactory(protocolAddressesArgs.opiumProxyFactory).burn(msg.sender, _positionAddress, _amount);\n\n        // Transfer payout * _amounts[i]\n        if (payout > 0) {\n            IERC20Upgradeable(opiumPositionTokenParams.derivative.token).safeTransfer(msg.sender, payout);\n        }\n\n        emit LogCancelled(msg.sender, opiumPositionTokenParams.derivativeHash, _amount);\n    }\n\n    /// @notice Helper function consumed by `Core._execute` to calculate the execution's payout of a settled derivative's position\n    /// @param _opiumPositionTokenParams it includes information about the derivative whose position is being executed { see OpiumPositionToken.sol for the implementation }\n    /// @param _amount uint256 amount of positions of the same type (either LONG or SHORT) whose payout is being calculated\n    /// @param _syntheticAggregator interface/address of `Opium SyntheticAggregator.sol`\n    /// @param _oracleAggregator interface/address of `Opium OracleAggregator.sol`\n    /// @return payout uint256 representing the net payout (gross payout - reserves) of the executed amount of positions\n    function _computePayout(\n        IOpiumPositionToken.OpiumPositionTokenParams memory _opiumPositionTokenParams,\n        uint256 _amount,\n        ISyntheticAggregator _syntheticAggregator,\n        IOracleAggregator _oracleAggregator\n    ) private returns (uint256 payout) {\n        /// if the derivativePayout tuple's items (buyer payout and seller payout) are 0, it assumes it's the first time the _computePayout function is being executed, hence it fetches the payouts from the syntheticId and caches them.\n        (uint256 buyerPayoutRatio, uint256 sellerPayoutRatio) = _getDerivativePayouts(\n            _opiumPositionTokenParams.derivativeHash\n        ); // gas saving\n        if (buyerPayoutRatio == 0 && sellerPayoutRatio == 0) {\n            /// fetches the derivative's data from the related oracleId\n            /// opium allows the usage of \"dummy\" oracleIds - oracleIds whose address is null - in which case the data is set to 0\n            uint256 data = _opiumPositionTokenParams.derivative.oracleId == address(0)\n                ? 0\n                : _oracleAggregator.getData(\n                    _opiumPositionTokenParams.derivative.oracleId,\n                    _opiumPositionTokenParams.derivative.endTime\n                );\n            // Get payout ratio from Derivative logic\n            // payoutRatio[0] - buyerPayout\n            // payoutRatio[1] - sellerPayout\n            (buyerPayoutRatio, sellerPayoutRatio) = IDerivativeLogic(_opiumPositionTokenParams.derivative.syntheticId)\n                .getExecutionPayout(_opiumPositionTokenParams.derivative, data);\n            derivativePayouts[_opiumPositionTokenParams.derivativeHash] = [buyerPayoutRatio, sellerPayoutRatio]; // gas saving\n        }\n\n        ISyntheticAggregator.SyntheticCache memory syntheticCache = _syntheticAggregator.getOrCacheSyntheticCache(\n            _opiumPositionTokenParams.derivativeHash,\n            _opiumPositionTokenParams.derivative\n        );\n\n        uint256 positionMargin;\n\n        // Check if `_positionType` is LONG\n        if (_opiumPositionTokenParams.positionType == LibDerivative.PositionType.LONG) {\n            // Calculates buyerPayout from ratio = (buyerMargin + sellerMargin) * buyerPayoutRatio / (buyerPayoutRatio + sellerPayoutRatio)\n            // Set payout to buyerPayout multiplied by amount\n            payout = (((syntheticCache.buyerMargin + syntheticCache.sellerMargin) * buyerPayoutRatio) /\n                (buyerPayoutRatio + sellerPayoutRatio)).mulWithPrecisionFactor(_amount);\n            // sets positionMargin to buyerMargin * amount\n            positionMargin = syntheticCache.buyerMargin.mulWithPrecisionFactor(_amount);\n            // Check if `_positionType` is a SHORT position\n        } else {\n            // Calculates sellerPayout from ratio = sellerPayout = (buyerMargin + sellerMargin) * sellerPayoutRatio / (buyerPayoutRatio + sellerPayoutRatio)\n            // Set payout to sellerPayout multiplied by amount\n            payout = (((syntheticCache.buyerMargin + syntheticCache.sellerMargin) * sellerPayoutRatio) /\n                (buyerPayoutRatio + sellerPayoutRatio)).mulWithPrecisionFactor(_amount);\n            // sets positionMargin to sellerMargin * amount\n            positionMargin = syntheticCache.sellerMargin.mulWithPrecisionFactor(_amount);\n        }\n\n        _decreaseP2PVault(_opiumPositionTokenParams.derivativeHash, payout);\n\n        // The reserves are deducted only from profitable positions: payout > positionMargin * amount\n        if (payout > positionMargin) {\n            payout =\n                payout -\n                _computeReserves(\n                    syntheticCache.authorAddress,\n                    _opiumPositionTokenParams.derivative.token,\n                    protocolAddressesArgs.protocolExecutionReserveClaimer,\n                    syntheticCache.authorCommission,\n                    protocolParametersArgs.protocolExecutionReservePart,\n                    payout - positionMargin\n                );\n        }\n    }\n\n    /// @notice It computes the total reserve to be distributed to the recipients provided as arguments\n    /// @param _derivativeAuthorAddress address of the derivative author that receives a portion of the reserves being calculated\n    /// @param _tokenAddress address of the token being used to distribute the reserves\n    /// @param _protocolReserveReceiver  address of the designated recipient that receives a portion of the reserves being calculated\n    /// @param _reservePercentage uint256 portion of the reserves that is being distributed from initial amount\n    /// @param _protocolReservePercentage uint256 portion of the reserves that is being distributed to `_protocolReserveReceiver`\n    /// @param _initialAmount uint256 the amount from which the reserves will be detracted\n    /// @return totalReserve uint256 total reserves being calculated which corresponds to the sum of the reserves distributed to the derivative author and the designated recipient\n    function _computeReserves(\n        address _derivativeAuthorAddress,\n        address _tokenAddress,\n        address _protocolReserveReceiver,\n        uint256 _reservePercentage,\n        uint256 _protocolReservePercentage,\n        uint256 _initialAmount\n    ) private returns (uint256 totalReserve) {\n        totalReserve = (_initialAmount * _reservePercentage) / LibCalculator.PERCENTAGE_BASE;\n\n        // If totalReserve is zero, finish\n        if (totalReserve == 0) {\n            return 0;\n        }\n\n        uint256 protocolReserve = (totalReserve * _protocolReservePercentage) / LibCalculator.PERCENTAGE_BASE;\n\n        // Update reservesVault for _protocolReserveReceiver\n        reservesVault[_protocolReserveReceiver][_tokenAddress] += protocolReserve;\n\n        // Update reservesVault for `syntheticId` author\n        reservesVault[_derivativeAuthorAddress][_tokenAddress] += totalReserve - protocolReserve;\n    }\n\n    /// @notice It increases the balance associated to a given derivative stored in the p2pVaults mapping\n    /// @param _derivativeHash unique identifier of a derivative which is used as a key in the p2pVaults mapping\n    /// @param _amount uint256 representing how much the p2pVaults derivative's balance will increase\n    function _increaseP2PVault(bytes32 _derivativeHash, uint256 _amount) private {\n        p2pVaults[_derivativeHash] += _amount;\n    }\n\n    /// @notice It decreases the balance associated to a given derivative stored in the p2pVaults mapping\n    /// @param _derivativeHash unique identifier of a derivative which is used as a key in the p2pVaults mapping\n    /// @param _amount uint256 representing how much the p2pVaults derivative's balance will decrease\n    function _decreaseP2PVault(bytes32 _derivativeHash, uint256 _amount) private {\n        require(p2pVaults[_derivativeHash] >= _amount, \"C9\");\n        p2pVaults[_derivativeHash] -= _amount;\n    }\n\n    // ***** GETTERS *****\n\n    /// @notice ensures that a token was minted by the OpiumProxyFactory\n    /// @dev usage of a private function rather than a modifier to avoid `stack too deep` error\n    /// @param _tokenAddress address of the erc20 token to validate\n    /// @param _opiumPositionTokenParams derivatives data of the token to validate\n    function _onlyOpiumFactoryTokens(\n        address _tokenAddress,\n        IOpiumPositionToken.OpiumPositionTokenParams memory _opiumPositionTokenParams\n    ) private view {\n        address predicted = _opiumPositionTokenParams.derivativeHash.predictDeterministicAddress(\n            _opiumPositionTokenParams.positionType == LibDerivative.PositionType.LONG,\n            IOpiumProxyFactory(protocolAddressesArgs.opiumProxyFactory).getImplementationAddress(),\n            address(protocolAddressesArgs.opiumProxyFactory)\n        );\n        require(_tokenAddress == predicted, \"C14\");\n    }\n\n    /// @notice private getter to destructure the derivativePayouts tuple. its only purpose is gas optimization\n    /// @param _derivativeHash bytes32 identifier of the derivative whose payout is being fetched\n    function _getDerivativePayouts(bytes32 _derivativeHash) private view returns (uint256, uint256) {\n        return (derivativePayouts[_derivativeHash][0], derivativePayouts[_derivativeHash][1]);\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/IOpiumPositionToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../libs/LibDerivative.sol\";\n\ninterface IOpiumPositionToken is IERC20PermitUpgradeable, IERC20Upgradeable {\n    struct OpiumPositionTokenParams {\n        LibDerivative.Derivative derivative;\n        LibDerivative.PositionType positionType;\n        bytes32 derivativeHash;\n    }\n\n    function initialize(\n        bytes32 _derivativeHash,\n        LibDerivative.PositionType _positionType,\n        LibDerivative.Derivative calldata _derivative\n    ) external;\n\n    function mint(address _positionOwner, uint256 _amount) external;\n\n    function burn(address _positionOwner, uint256 _amount) external;\n\n    function getFactoryAddress() external view returns (address);\n\n    function getPositionTokenData() external view returns (OpiumPositionTokenParams memory opiumPositionTokenParams);\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) external;\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) external;\n}\n"
    },
    "contracts/interfaces/IDerivativeLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../libs/LibDerivative.sol\";\n\n/// @title Opium.Interface.IDerivativeLogic is an interface that every syntheticId should implement\ninterface IDerivativeLogic {\n    // Event with syntheticId metadata JSON string (for DIB.ONE derivative explorer)\n    event LogMetadataSet(string metadata);\n\n    /// @notice Validates ticker\n    /// @param _derivative Derivative Instance of derivative to validate\n    /// @return Returns boolean whether ticker is valid\n    function validateInput(LibDerivative.Derivative memory _derivative) external view returns (bool);\n\n    /// @return Returns the custom name of a derivative ticker which will be used as part of the name of its positions\n    function getSyntheticIdName() external view returns (string memory);\n\n    /// @notice Calculates margin required for derivative creation\n    /// @param _derivative Derivative Instance of derivative\n    /// @return buyerMargin uint256 Margin needed from buyer (LONG position)\n    /// @return sellerMargin uint256 Margin needed from seller (SHORT position)\n    function getMargin(LibDerivative.Derivative memory _derivative)\n        external\n        view\n        returns (uint256 buyerMargin, uint256 sellerMargin);\n\n    /// @notice Calculates payout for derivative execution\n    /// @param _derivative Derivative Instance of derivative\n    /// @param _result uint256 Data retrieved from oracleId on the maturity\n    /// @return buyerPayout uint256 Payout in ratio for buyer (LONG position holder)\n    /// @return sellerPayout uint256 Payout in ratio for seller (SHORT position holder)\n    function getExecutionPayout(LibDerivative.Derivative memory _derivative, uint256 _result)\n        external\n        view\n        returns (uint256 buyerPayout, uint256 sellerPayout);\n\n    /// @notice Returns syntheticId author address for Opium commissions\n    /// @return authorAddress address The address of syntheticId address\n    function getAuthorAddress() external view returns (address authorAddress);\n\n    /// @notice Returns syntheticId author commission in base of COMMISSION_BASE\n    /// @return commission uint256 Author commission\n    function getAuthorCommission() external view returns (uint256 commission);\n\n    /// @notice Returns whether thirdparty could execute on derivative's owner's behalf\n    /// @param _derivativeOwner address Derivative owner address\n    /// @return Returns boolean whether _derivativeOwner allowed third party execution\n    function thirdpartyExecutionAllowed(address _derivativeOwner) external view returns (bool);\n\n    /// @notice Sets whether thirds parties are allowed or not to execute derivative's on msg.sender's behalf\n    /// @param _allow bool Flag for execution allowance\n    function allowThirdpartyExecution(bool _allow) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/test/upgradeability/TestCoreUpgrade.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../../core/Core.sol\";\n\n/// @title Opium.Core contract creates positions, holds and distributes margin at the maturity\ncontract TestCoreUpgrade is Core {\n    function placeholder() external pure returns (string memory) {\n        return \"upgraded\";\n    }\n}\n"
    },
    "contracts/test/mocks/synthetics/RatioCdsSyntheticId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\nimport \"../../../interfaces/IDerivativeLogic.sol\";\n\ncontract RatioCdsSyntheticId is IDerivativeLogic, Ownable {\n  address private author;\n  uint256 private commission;\n\n  uint256 constant public TRIGGER_BASE = 1e18;\n\n\n  constructor(address _author, uint256 _commission) {\n    /*\n    {\n      \"author\": \"Opium.Team\",\n      \"type\": \"swap\",\n      \"subtype\": \"cds\",\n      \"description\": \"Ratio CDS logic contract\"\n    }\n    */\n    emit LogMetadataSet(\"{\\\"author\\\":\\\"Opium.Team\\\",\\\"type\\\":\\\"swap\\\",\\\"subtype\\\":\\\"cds\\\",\\\"description\\\":\\\"Ratio CDS logic contract\\\"}\");\n    \n    author = _author;\n    commission = _commission;\n  }\n\n  /// @return Returns the custom name of a derivative ticker which will be used as part of the name of its positions\n  function getSyntheticIdName() external pure override returns (string memory) {\n    return \"CDS\";\n  }\n\n  // params[0] - Trigger\n  // params[1] - Fixed Premium\n  function validateInput(LibDerivative.Derivative calldata _derivative) external view override returns (bool) {\n    return (\n      // Derivative\n      _derivative.endTime > block.timestamp &&\n      _derivative.margin > 0 &&\n      _derivative.params.length == 2 &&\n\n      _derivative.params[0] > 0 && // Trigger\n      _derivative.params[0] <= TRIGGER_BASE // Trigger\n    );\n  }\n\n  function getMargin(LibDerivative.Derivative calldata _derivative) external pure override returns (uint256 buyerMargin, uint256 sellerMargin) {\n    uint256 fixedPremium = _derivative.params[1];\n    uint256 nominal = _derivative.margin;\n    buyerMargin = fixedPremium;\n    sellerMargin = nominal;\n  }\n\n  function getExecutionPayout(LibDerivative.Derivative calldata _derivative, uint256 _result) external pure override returns (uint256 buyerPayout, uint256 sellerPayout) {\n    uint256 trigger = _derivative.params[0];\n    uint256 fixedPremium = _derivative.params[1];\n    uint256 nominal = _derivative.margin;\n\n    if (_result < trigger) {\n      sellerPayout = nominal * _result / TRIGGER_BASE;\n      buyerPayout = nominal - sellerPayout;\n    } else {\n      buyerPayout = 0;\n      sellerPayout = nominal;\n    }\n\n    // Add premium\n    sellerPayout = sellerPayout + fixedPremium;\n  }\n\n  /** COMMISSION */\n  /// @notice Getter for syntheticId author address\n  /// @return address syntheticId author address\n  function getAuthorAddress() external view override returns (address) {\n    return author;\n  }\n\n  /// @notice Getter for syntheticId author commission\n  /// @return uint26 syntheticId author commission\n  function getAuthorCommission() external view override returns (uint256) {\n    return commission;\n  }\n\n  /** THIRDPARTY EXECUTION */\n  function thirdpartyExecutionAllowed(address) external pure override returns (bool) {\n    return true;\n  }\n\n  function allowThirdpartyExecution(bool) external pure override {\n  }\n\n  /** GOVERNANCE */\n  function setAuthorAddress(address _author) external onlyOwner {\n    require(_author != address(0), \"Can't set to zero address\");\n    author = _author;\n  }\n\n  function setAuthorCommission(uint256 _commission) external onlyOwner {\n    commission = _commission;\n  }\n}\n"
    },
    "contracts/test/mocks/synthetics/OptionPutPartSyntheticId.sol": {
      "content": "pragma solidity 0.8.5;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../../../interfaces/IDerivativeLogic.sol\";\n\ncontract OptionPutPartSyntheticId is IDerivativeLogic, Ownable {\n    address private immutable author;\n    uint256 private immutable part;\n\n    uint256 private constant commission = 25; // 0.25% of profit\n    uint256 public constant BASE_PPT = 1e18;\n\n    constructor(address _author, uint256 _part) {\n        emit LogMetadataSet(\n            '{\"author\":\"Opium.Team\",\"type\":\"option\",\"subtype\":\"put\",\"description\":\"Option Put logic contract\"}'\n        );\n\n        author = _author;\n        part = _part;\n\n        transferOwnership(_author);\n    }\n\n    // params[0] - Strike price\n    // params[1] - PPT (Sensitivity)\n    // params[2] - fixedPremium\n    function validateInput(LibDerivative.Derivative memory _derivative) public view override returns (bool) {\n        return (_derivative.endTime > block.timestamp &&\n            _derivative.margin > 0 &&\n            _derivative.params.length == 3 &&\n            _derivative.params[0] > 0 && // Strike price > 0\n            _derivative.params[1] > 0); // PPT > 0\n    }\n\n    function getMargin(LibDerivative.Derivative memory _derivative)\n        external\n        view\n        override\n        returns (uint256 buyerMargin, uint256 sellerMargin)\n    {\n        uint256 fixedPremium = _derivative.params[2];\n        buyerMargin = fixedPremium;\n        uint256 nominal = _derivative.margin;\n        sellerMargin = (nominal * part) / BASE_PPT;\n    }\n\n    function getExecutionPayout(LibDerivative.Derivative memory _derivative, uint256 _result)\n        external\n        view\n        override\n        returns (uint256 buyerPayout, uint256 sellerPayout)\n    {\n        uint256 strikePrice = _derivative.params[0];\n        // uint256 ppt = _derivative.params[1];  // Ignore PPT\n        uint256 fixedPremium = _derivative.params[2];\n        uint256 nominal = _derivative.margin;\n        uint256 sellerMargin = (nominal * part) / BASE_PPT;\n\n        // If result price is lower than strike price, buyer is paid out\n        if (_result < strikePrice) {\n            // buyer payout = margin * (strike price  - result) / strike price\n            buyerPayout = (nominal * (strikePrice - _result) / strikePrice);\n\n            if (buyerPayout > sellerMargin) {\n                buyerPayout = sellerMargin;\n            }\n\n            // seller payout = margin - buyer payout\n            sellerPayout = sellerMargin - buyerPayout;\n        } else {\n            // buyer payout = 0\n            buyerPayout = 0;\n\n            // seller payout = margin\n            sellerPayout = sellerMargin;\n        }\n\n        // Add fixed premium to seller payout\n        sellerPayout = sellerPayout + fixedPremium;\n    }\n\n    /** COMMISSION */\n    /// @notice Getter for syntheticId author address\n    /// @return address syntheticId author address\n    function getAuthorAddress() public view override returns (address) {\n        return author;\n    }\n\n    /// @notice Getter for syntheticId author commission\n    /// @return uint26 syntheticId author commission\n    function getAuthorCommission() public pure override returns (uint256) {\n        return commission;\n    }\n\n    /// @return Returns the custom name of a derivative ticker which will be used as part of the name of its positions\n    function getSyntheticIdName() external pure override returns (string memory) {\n        return \"OPT-P\";\n    }\n\n    /** THIRDPARTY EXECUTION */\n    function thirdpartyExecutionAllowed(address derivativeOwner) public pure override returns (bool) {\n        return true;\n    }\n\n    function allowThirdpartyExecution(bool allow) external override {}\n}\n"
    },
    "contracts/test/mocks/synthetics/OptionCallDeliverySyntheticId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../../../interfaces/IDerivativeLogic.sol\";\n\ncontract OptionCallDeliverySyntheticId is IDerivativeLogic, Ownable {\n  address private author;\n  uint256 private commission;\n\n  constructor(address _author, uint256 _commission) {\n    /*\n    {\n      \"author\": \"Opium.Team\",\n      \"type\": \"option\",\n      \"subtype\": \"call\",\n      \"description\": \"Option Call with delivery logic contract\"\n    }\n    */\n    emit LogMetadataSet(\"{\\\"author\\\":\\\"Opium.Team\\\",\\\"type\\\":\\\"option\\\",\\\"subtype\\\":\\\"call\\\",\\\"description\\\":\\\"Option Call with delivery logic contract\\\"}\");\n    \n    author = _author;\n    commission = _commission;\n  }\n\n  /// @return Returns the custom name of a derivative ticker which will be used as part of the name of its positions\n  function getSyntheticIdName() external pure override returns (string memory) {\n    return \"OPT-C\";\n  }\n\n  // params[0] - Strike price\n  // params[1] - fixedPremium\n  function validateInput(LibDerivative.Derivative calldata _derivative) public view override returns (bool) {\n    return (\n      // Derivative\n      _derivative.endTime > block.timestamp &&\n      _derivative.margin > 0 &&\n      _derivative.params.length == 2 &&\n\n      _derivative.params[0] > 0 // Strike price > 0\n    );\n  }\n\n  function getMargin(LibDerivative.Derivative calldata _derivative) external pure override returns (uint256 buyerMargin, uint256 sellerMargin) {\n    uint256 fixedPremium = _derivative.params[1];\n    uint256 nominal = _derivative.margin;\n    buyerMargin = fixedPremium;\n    sellerMargin = nominal;\n  }\n\n  function getExecutionPayout(LibDerivative.Derivative calldata _derivative, uint256 _result) external pure override returns (uint256 buyerPayout, uint256 sellerPayout) {\n    uint256 strikePrice = _derivative.params[0];\n    uint256 fixedPremium = _derivative.params[1];\n    uint256 nominal = _derivative.margin;\n\n    if (_result > strikePrice) {\n      // buyer payout = margin * (result - strike price) / result\n      buyerPayout = nominal * (_result - strikePrice) / _result;\n\n      // seller payout = margin - buyer payout\n      sellerPayout = nominal - buyerPayout;\n    } else {\n      // buyer payout = 0\n      buyerPayout = 0;\n      \n      // seller payout = margin\n      sellerPayout = nominal;\n    }\n\n    // Add fixed premium to seller payout\n    sellerPayout = sellerPayout + fixedPremium;\n  }\n\n  /** COMMISSION */\n  /// @notice Getter for syntheticId author address\n  /// @return address syntheticId author address\n  function getAuthorAddress() public view override returns (address) {\n    return author;\n  }\n\n  /// @notice Getter for syntheticId author commission\n  /// @return uint26 syntheticId author commission\n  function getAuthorCommission() external view override returns (uint256) {\n    return commission;\n  }\n\n  /** THIRDPARTY EXECUTION */\n  function thirdpartyExecutionAllowed(address) external pure override returns (bool) {\n    return true;\n  }\n\n  function allowThirdpartyExecution(bool) external override {}\n\n  /** GOVERNANCE */\n  function setAuthorAddress(address _author) public onlyOwner {\n    require(_author != address(0), \"Can't set to zero address\");\n    author = _author;\n  }\n\n  function setAuthorCommission(uint256 _commission) external onlyOwner {\n    commission = _commission;\n  }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/test/mocks/TestToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    address public owner;\n    uint8 private customDecimals;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        owner = msg.sender;\n        customDecimals = _decimals;\n        _mint(msg.sender, 100e12 * 10**customDecimals);\n    }\n\n    function mint(address _to, uint256 _amount) public {\n        require(msg.sender == owner, \"Only owner can mint\");\n        _mint(_to, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return customDecimals;\n    }\n}\n"
    },
    "contracts/helpers/OnChainDerivativeTracker.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"../libs/LibPosition.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"../interfaces/IOpiumProxyFactory.sol\";\nimport \"../interfaces/IOpiumPositionToken.sol\";\n\ninterface IERC20Extended is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n}\n\nstruct PositionTotalSupply {\n    address positionAddress;\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    LibDerivative.Derivative derivative;\n    bool isLong;\n}\n\ncontract OnChainDerivativeTracker {\n    using LibPosition for bytes32;\n\n    IRegistry public immutable registry;\n\n    constructor(address _registry) {\n        registry = IRegistry(_registry);\n    }\n\n    function getDerivativePositionsSupply(bytes32 _derivativeHash)\n        external\n        view\n        returns (PositionTotalSupply[2] memory)\n    {\n        return _getDerivativePositionsSupply(_derivativeHash);\n    }\n\n    function getDerivativesPositionsSupply(bytes32[] calldata _derivativesHash)\n        external\n        view\n        returns (PositionTotalSupply[2][] memory)\n    {\n        PositionTotalSupply[2][] memory positionsTotalSupply = new PositionTotalSupply[2][](_derivativesHash.length);\n        for (uint256 i = 0; i < _derivativesHash.length; i++) {\n            positionsTotalSupply[i] = _getDerivativePositionsSupply(_derivativesHash[i]);\n        }\n        return positionsTotalSupply;\n    }\n\n    function _getDerivativePositionsSupply(bytes32 _derivativeHash)\n        private\n        view\n        returns (PositionTotalSupply[2] memory)\n    {\n        IOpiumProxyFactory opiumProxyFactory = IOpiumProxyFactory(registry.getProtocolAddresses().opiumProxyFactory);\n\n        address longPositionAddress = _derivativeHash.predictDeterministicAddress(\n            true,\n            opiumProxyFactory.getImplementationAddress(),\n            address(opiumProxyFactory)\n        );\n        address shortPositionAddress = _derivativeHash.predictDeterministicAddress(\n            false,\n            opiumProxyFactory.getImplementationAddress(),\n            address(opiumProxyFactory)\n        );\n\n        return [\n            PositionTotalSupply({\n                positionAddress: longPositionAddress,\n                name: IERC20Extended(longPositionAddress).name(),\n                symbol: IERC20Extended(longPositionAddress).symbol(),\n                totalSupply: IERC20Extended(longPositionAddress).totalSupply(),\n                derivative: IOpiumPositionToken(longPositionAddress).getPositionTokenData().derivative,\n                isLong: true\n            }),\n            PositionTotalSupply({\n                positionAddress: shortPositionAddress,\n                name: IERC20Extended(shortPositionAddress).name(),\n                symbol: IERC20Extended(shortPositionAddress).symbol(),\n                totalSupply: IERC20Extended(shortPositionAddress).totalSupply(),\n                derivative: IOpiumPositionToken(shortPositionAddress).getPositionTokenData().derivative,\n                isLong: false\n            })\n        ];\n    }\n}\n"
    },
    "contracts/core/OpiumProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"./OpiumPositionToken.sol\";\nimport \"./base/RegistryManager.sol\";\nimport \"../libs/LibDerivative.sol\";\nimport \"../libs/LibPosition.sol\";\nimport \"../libs/LibBokkyPooBahsDateTimeLibrary.sol\";\nimport \"../interfaces/IOpiumPositionToken.sol\";\nimport \"../interfaces/IRegistry.sol\";\n\n/**\n    Error codes:\n    - F1 = ERROR_OPIUM_PROXY_FACTORY_NOT_CORE\n    - F2 = ERROR_OPIUM_PROXY_CUSTOM_POSITION_TOKEN_NAME_TOO_LONG\n */\n\n/// @title Opium.OpiumProxyFactory contract manages the deployment of ERC20 LONG/SHORT positions for a given `LibDerivative.Derivative` structure and it's responsible for minting and burning positions according to the parameters supplied by `Opium.Core`\ncontract OpiumProxyFactory is RegistryManager {\n    using LibDerivative for LibDerivative.Derivative;\n    using LibPosition for bytes32;\n\n    event LogPositionTokenPair(\n        bytes32 indexed _derivativeHash,\n        address indexed _longPositionAddress,\n        address indexed _shortPositionAddress\n    );\n\n    address private opiumPositionTokenImplementation;\n\n    /// @notice It is applied to functions that must be called only by the `Opium.Core` contract\n    modifier onlyCore() {\n        require(msg.sender == registry.getCore(), \"F1\");\n        _;\n    }\n\n    // ****************** EXTERNAL FUNCTIONS ******************\n\n    // ***** GETTERS *****\n\n    /// @notice It retrieves the information about the underlying derivative\n    /// @return _opiumPositionTokenParams OpiumPositionTokenParams struct which contains `LibDerivative.Derivative` schema of the derivative, the ` LibDerivative.PositionType` of the present ERC20 token and the bytes32 hash `derivativeHash` of the `LibDerivative.Derivative` derivative\n    function getImplementationAddress() external view returns (address) {\n        return opiumPositionTokenImplementation;\n    }\n\n    // ***** SETTERS *****\n\n    /// @notice It is called only once upon deployment of the contract\n    /// @dev It sets the the address of the implementation of the OpiumPositionToken contract which will be used for the factory-deployment of erc20 positions via the minimal proxy contract\n    /// @param _registry address of Opium.Registry\n    function initialize(address _registry) external initializer {\n        __RegistryManager__init(_registry);\n        opiumPositionTokenImplementation = address(new OpiumPositionToken());\n    }\n\n    /// @notice It creates a specified amount of LONG/SHORT position tokens on behalf of the buyer(LONG) and seller(SHORT) - the specified amount can be 0 in which case the ERC20 contract of the position tokens will only be deployed\n    /// @dev if either of the LONG or SHORT position contracts already exists then it is expected to fail\n    /// @param _buyer address of the recipient of the LONG position tokens\n    /// @param _seller address of the recipient of the SHORT position tokens\n    /// @param _amount amount of position tokens to be minted to the _positionHolder\n    /// @param _derivativeHash bytes32 hash of `LibDerivative.Derivative`\n    /// @param _derivative LibDerivative.Derivative Derivative definition\n    function create(\n        address _buyer,\n        address _seller,\n        uint256 _amount,\n        bytes32 _derivativeHash,\n        LibDerivative.Derivative calldata _derivative\n    ) external onlyCore {\n        address longPositionAddress = _derivativeHash.deployOpiumPosition(true, opiumPositionTokenImplementation);\n        address shortPositionAddress = _derivativeHash.deployOpiumPosition(false, opiumPositionTokenImplementation);\n\n        IOpiumPositionToken(longPositionAddress).initialize(\n            _derivativeHash,\n            LibDerivative.PositionType.LONG,\n            _derivative\n        );\n        IOpiumPositionToken(shortPositionAddress).initialize(\n            _derivativeHash,\n            LibDerivative.PositionType.SHORT,\n            _derivative\n        );\n        emit LogPositionTokenPair(_derivativeHash, longPositionAddress, shortPositionAddress);\n        if (_amount > 0) {\n            IOpiumPositionToken(longPositionAddress).mint(_buyer, _amount);\n            IOpiumPositionToken(shortPositionAddress).mint(_seller, _amount);\n        }\n    }\n\n    /// @notice it creates a specified amount of LONG/SHORT position tokens on behalf of the buyer(LONG) and seller(SHORT) - the specified amount can be 0 in which case the ERC20 contract of the position tokens will only be deployed\n    /// @dev if LONG or SHORT position contracts have not been deployed yet at the provided addresses then it is expected to fail\n    /// @param _buyer address of the recipient of the LONG position tokens\n    /// @param _seller address of the recipient of the SHORT position tokens\n    /// @param _longPositionAddress address of the deployed LONG position token\n    /// @param _shortPositionAddress address of the deployed SHORT position token\n    /// @param _amount amount of position tokens to be minted to the _positionHolder\n    function mintPair(\n        address _buyer,\n        address _seller,\n        address _longPositionAddress,\n        address _shortPositionAddress,\n        uint256 _amount\n    ) external onlyCore {\n        IOpiumPositionToken(_longPositionAddress).mint(_buyer, _amount);\n        IOpiumPositionToken(_shortPositionAddress).mint(_seller, _amount);\n    }\n\n    /// @notice it burns specified amount of a specific position tokens on behalf of a specified owner\n    /// @notice it is consumed by Opium.Core to execute or cancel a specific position type\n    /// @dev if no position has been deployed at the provided address, it is expected to revert\n    /// @param _positionOwner address of the owner of the specified position token\n    /// @param _positionAddress address of the position token to be burnt\n    /// @param _amount amount of position tokens to be minted to the _positionHolder\n    function burn(\n        address _positionOwner,\n        address _positionAddress,\n        uint256 _amount\n    ) external onlyCore {\n        IOpiumPositionToken(_positionAddress).burn(_positionOwner, _amount);\n    }\n\n    /// @notice It burns the specified amount of LONG/SHORT position tokens on behalf of a specified owner\n    /// @notice It is consumed by Opium.Core to redeem market neutral position pairs\n    /// @param _positionOwner address of the owner of the LONG/SHORT position tokens\n    /// @param _longPositionAddress address of the deployed LONG position token\n    /// @param _shortPositionAddress address of the deployed SHORT position token\n    /// @param _amount amount of position tokens to be minted to the _positionHolder\n    function burnPair(\n        address _positionOwner,\n        address _longPositionAddress,\n        address _shortPositionAddress,\n        uint256 _amount\n    ) external onlyCore {\n        IOpiumPositionToken(_longPositionAddress).burn(_positionOwner, _amount);\n        IOpiumPositionToken(_shortPositionAddress).burn(_positionOwner, _amount);\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/core/OpiumPositionToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"../interfaces/IDerivativeLogic.sol\";\nimport \"../libs/LibDerivative.sol\";\nimport \"../libs/LibBokkyPooBahsDateTimeLibrary.sol\";\n\n/**\n    Error codes:\n    - P1 = ERROR_OPIUM_POSITION_TOKEN_NOT_FACTORY\n */\n\n/// @title Opium.OpiumPositionToken is an ERC20PermitUpgradeable child contract created by the Opium.OpiumProxyFactory. It represents a specific position (either LONG or SHORT) for a given `LibDerivative.Derivative` derivative\ncontract OpiumPositionToken is ERC20PermitUpgradeable {\n    using LibDerivative for LibDerivative.Derivative;\n\n    /// It describes the derivative whose position (either LONG or SHORT) is being represented by the OpiumPositionToken\n    struct OpiumPositionTokenParams {\n        LibDerivative.Derivative derivative;\n        LibDerivative.PositionType positionType;\n        bytes32 derivativeHash;\n    }\n\n    address private factory;\n    OpiumPositionTokenParams private opiumPositionTokenParams;\n\n    /// @notice It is applied to all the stateful functions in OpiumPositionToken as they are meant to be consumed only via the OpiumProxyFactory\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"P1\");\n        _;\n    }\n\n    // ****************** EXTERNAL FUNCTIONS ******************\n\n    // ***** SETTERS *****\n\n    /// @notice `it is called only once upon deployment of the contract\n    /// @dev it sets the state variables that are meant to be read-only and should be consumed by other contracts to retrieve information about the derivative\n    /// @param _derivativeHash bytes32 hash of `LibDerivative.Derivative`\n    /// @param _positionType  LibDerivative.PositionType _positionType describes whether the present ERC20 token is LONG or SHORT\n    /// @param _derivative LibDerivative.Derivative Derivative definition\n    function initialize(\n        bytes32 _derivativeHash,\n        LibDerivative.PositionType _positionType,\n        LibDerivative.Derivative calldata _derivative\n    ) external initializer {\n        __ERC20_init(\"\", \"\");\n        __EIP712_init_unchained(\"Opium Position Token\", \"1\");\n        __ERC20Permit_init_unchained(\"\");\n        factory = msg.sender;\n        opiumPositionTokenParams = OpiumPositionTokenParams({\n            derivative: _derivative,\n            positionType: _positionType,\n            derivativeHash: _derivativeHash\n        });\n    }\n\n    /// @notice it mints a specified amount of tokens to the given address\n    /// @dev can only be called by the factory contract set in the `initialize` function\n    /// @param _positionOwner address of the recipient of the position tokens\n    /// @param _amount amount of position tokens to be minted to the _positionOwner\n    function mint(address _positionOwner, uint256 _amount) external onlyFactory {\n        _mint(_positionOwner, _amount);\n    }\n\n    /// @notice it burns a specified amount of tokens owned by the given address\n    /// @dev can only be called by the factory contract set in the `initialize` function\n    /// @param _positionOwner address of the owner of the position tokens\n    /// @param _amount amount of position tokens to be burnt\n    function burn(address _positionOwner, uint256 _amount) external onlyFactory {\n        _burn(_positionOwner, _amount);\n    }\n\n    // ***** GETTERS *****\n\n    /// @notice It retrieves the address of the factory contract set in the `initialize` function\n    /// @return address of the factory contract (OpiumProxyFactory)\n    function getFactoryAddress() external view returns (address) {\n        return factory;\n    }\n\n    /// @notice It retrieves all the stored information about the underlying derivative\n    /// @return _opiumPositionTokenParams OpiumPositionTokenParams struct which contains `LibDerivative.Derivative` schema of the derivative, the `LibDerivative.PositionType` of the present ERC20 token and the bytes32 hash `derivativeHash` of the `LibDerivative.Derivative` derivative\n    function getPositionTokenData() external view returns (OpiumPositionTokenParams memory _opiumPositionTokenParams) {\n        return opiumPositionTokenParams;\n    }\n\n    // ****************** PUBLIC FUNCTIONS ******************\n\n    /**\n     * @notice It overrides the OpenZeppelin name() getter and returns a custom erc20 name which is derived from the endTime of the erc20 token's associated derivative's maturity, the custom derivative name chosen by the derivative author and the derivative hash\n     */\n    function name() public view override returns (string memory) {\n        string memory derivativeAuthorCustomName = IDerivativeLogic(opiumPositionTokenParams.derivative.syntheticId).getSyntheticIdName();\n        string memory derivativeHashSlice = _toDerivativeHashStringIdentifier(opiumPositionTokenParams.derivativeHash);\n        bytes memory endTimeDate = _toDerivativeEndTimeIdentifier(opiumPositionTokenParams.derivative.endTime);\n        bytes memory baseCustomName = abi.encodePacked(\n            \"Opium:\",\n            endTimeDate,\n            \"-\",\n            derivativeAuthorCustomName,\n            \"-\",\n            derivativeHashSlice\n        );\n        return\n            string(\n                abi.encodePacked(\n                    baseCustomName,\n                    opiumPositionTokenParams.positionType == LibDerivative.PositionType.LONG ? \"-LONG\" : \"-SHORT\"\n                )\n            );\n    }\n\n    /**\n     * @notice It overrides the OpenZeppelin symbol() getter and returns a custom erc20 symbol which is derived from the endTime of the erc20 token's associated derivative's maturity, the custom derivative name chosen by the derivative author and the derivative hash\n     */\n    function symbol() public view override returns (string memory) {\n        string memory derivativeAuthorCustomName = IDerivativeLogic(opiumPositionTokenParams.derivative.syntheticId).getSyntheticIdName();\n        string memory derivativeHashSlice = _toDerivativeHashStringIdentifier(opiumPositionTokenParams.derivativeHash);\n        bytes memory endTimeDate = _toDerivativeEndTimeIdentifier(opiumPositionTokenParams.derivative.endTime);\n        bytes memory customSymbol = abi.encodePacked(\n            \"OPIUM\",\n            \"_\",\n            endTimeDate,\n            \"_\",\n            derivativeAuthorCustomName,\n            \"_\",\n            derivativeHashSlice\n        );\n        return\n            string(\n                abi.encodePacked(\n                    customSymbol,\n                    opiumPositionTokenParams.positionType == LibDerivative.PositionType.LONG ? \"_L\" : \"_S\"\n                )\n            );\n    }\n\n    // ****************** PRIVATE FUNCTIONS ******************\n\n    /// @notice It is used to obtain a slice of derivativeHash and convert it to a string to be used as part of an Opium position token's name\n    /// @param _data bytes32 representing a derivativeHash\n    /// @return string representing the first 4 characters of a derivativeHash prefixed by \"0x\"\n    function _toDerivativeHashStringIdentifier(bytes32 _data) private pure returns (string memory) {\n        bytes4 result;\n        assembly {\n            result := or(\n                and(\n                    or(\n                        shr(4, and(_data, 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000)),\n                        shr(8, and(_data, 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00))\n                    ),\n                    0xffff000000000000000000000000000000000000000000000000000000000000\n                ),\n                shr(\n                    16,\n                    or(\n                        shr(4, and(shl(8, _data), 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000)),\n                        shr(8, and(shl(8, _data), 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00))\n                    )\n                )\n            )\n        }\n\n        return\n            string(\n                abi.encodePacked(\n                    \"0x\",\n                    bytes4(0x30303030 + uint32(result) + (((uint32(result) + 0x06060606) >> 4) & 0x0F0F0F0F) * 7)\n                )\n            );\n    }\n\n    /// @notice It is used to convert a derivative.endTime to a human-readable date to be used as part of an Opium position token's name\n    /// @dev { See the third-party library ./libs/LibBokkyPooBahsDateTimeLibrary.sol }\n    /// @param _derivativeEndTime uint256 representing the timestamp of a given derivative's maturity\n    /// @return bytes representing the encoding of the derivativeEndTime converted to day-month-year in the format DD/MM/YYYY\n    function _toDerivativeEndTimeIdentifier(uint256 _derivativeEndTime) private pure returns (bytes memory) {\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(_derivativeEndTime);\n\n        return\n            abi.encodePacked(\n                StringsUpgradeable.toString(year),\n                month < 10\n                    ? abi.encodePacked(\"0\", StringsUpgradeable.toString(month))\n                    : bytes(StringsUpgradeable.toString(month)),\n                day < 10\n                    ? abi.encodePacked(\"0\", StringsUpgradeable.toString(day))\n                    : bytes(StringsUpgradeable.toString(day))\n            );\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    // The gaps left for the `OpiumPositionToken` are less than the slots allocated for the other upgradeable contracts in the protocol because the OpiumPositionToken is the only contract that is programmatically deployed (frequently), hence we want to minimize the gas cost\n    uint256[30] private __gap;\n}\n"
    },
    "contracts/libs/LibBokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.5;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\n// version v1.01\nlibrary BokkyPooBahsDateTimeLibrary {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal onlyInitializing {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/test/mocks/MaliciousTestToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../../libs/LibDerivative.sol\";\nimport \"../../libs/LibPosition.sol\";\n\ncontract MaliciousTestToken is ERC20 {\n    address public owner;\n    uint8 private customDecimals;\n\n    struct OpiumPositionTokenParams {\n        LibDerivative.Derivative derivative;\n        LibDerivative.PositionType positionType;\n        bytes32 derivativeHash;\n    }\n\n    OpiumPositionTokenParams private opiumPositionTokenParams;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) {\n        owner = msg.sender;\n        customDecimals = _decimals;\n        _mint(msg.sender, 100e12 * 10**customDecimals);\n    }\n\n    function mint(address _to, uint256 _amount) public {\n        require(msg.sender == owner, \"Only owner can mint\");\n        _mint(_to, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return customDecimals;\n    }\n\n    function getPositionTokenData() external view returns (OpiumPositionTokenParams memory opiumPositionTokenParams) {}\n}\n"
    },
    "contracts/helpers/PayoutHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../interfaces/IDerivativeLogic.sol\";\nimport \"../libs/LibDerivative.sol\";\n\ncontract PayoutHelper {\n    struct ExecutionPayout {\n        uint256 buyerPayout;\n        uint256 sellerPayout;\n    }\n\n    function getExecutionPayouts(LibDerivative.Derivative calldata _derivative, uint256[] calldata _results)\n        external\n        view\n        returns (ExecutionPayout[] memory executionPayouts)\n    {\n        IDerivativeLogic logic = IDerivativeLogic(_derivative.syntheticId);\n\n        executionPayouts = new ExecutionPayout[](_results.length);\n\n        for (uint256 i = 0; i < _results.length; i++) {\n            (uint256 buyerPayout, uint256 sellerPayout) = logic.getExecutionPayout(_derivative, _results[i]);\n            executionPayouts[i] = ExecutionPayout(buyerPayout, sellerPayout);\n        }\n    }\n}\n"
    },
    "contracts/core/SyntheticAggregator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./base/RegistryManager.sol\";\nimport \"../interfaces/IDerivativeLogic.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"../libs/LibDerivative.sol\";\n\n/**\n    Error codes:\n    - S1 = ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH\n    - S2 = ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN\n    - S3 = ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG\n */\n\n/// @notice Opium.SyntheticAggregator contract initialized, identifies and caches syntheticId sensitive data\ncontract SyntheticAggregator is ReentrancyGuardUpgradeable, RegistryManager {\n    using LibDerivative for LibDerivative.Derivative;\n\n    // Emitted when new ticker is initialized\n    event LogSyntheticInit(LibDerivative.Derivative indexed derivative, bytes32 indexed derivativeHash);\n\n    struct SyntheticCache {\n        uint256 buyerMargin;\n        uint256 sellerMargin;\n        uint256 authorCommission;\n        address authorAddress;\n        bool init;\n    }\n    mapping(bytes32 => SyntheticCache) private syntheticCaches;\n\n    // ****************** EXTERNAL FUNCTIONS ******************\n\n    function initialize(address _registry) external initializer {\n        __RegistryManager__init(_registry);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Initializes ticker, if was not initialized and returns buyer and seller margin from cache\n    /// @param _derivativeHash bytes32 hash of derivative\n    /// @param _derivative LibDerivative.Derivative itself\n    /// @return buyerMargin uint256 Margin of buyer\n    /// @return sellerMargin uint256 Margin of seller\n    function getOrCacheMargin(bytes32 _derivativeHash, LibDerivative.Derivative calldata _derivative)\n        external\n        returns (uint256 buyerMargin, uint256 sellerMargin)\n    {\n        // Initialize derivative if wasn't initialized before\n        if (!syntheticCaches[_derivativeHash].init) {\n            _initDerivative(_derivativeHash, _derivative);\n        }\n        return (syntheticCaches[_derivativeHash].buyerMargin, syntheticCaches[_derivativeHash].sellerMargin);\n    }\n\n    /// @notice Initializes ticker if not previously initialized and returns the cached `syntheticId` data\n    /// @param _derivativeHash bytes32 hash of derivative\n    /// @param _derivative LibDerivative.Derivative itself\n    function getOrCacheSyntheticCache(bytes32 _derivativeHash, LibDerivative.Derivative calldata _derivative)\n        external\n        returns (SyntheticCache memory)\n    {\n        // Initialize derivative if wasn't initialized before\n        if (!syntheticCaches[_derivativeHash].init) {\n            _initDerivative(_derivativeHash, _derivative);\n        }\n        return syntheticCaches[_derivativeHash];\n    }\n\n    // ****************** PRIVATE FUNCTIONS ******************\n\n    /// @notice Initializes ticker: caches syntheticId type, margin, author address and commission\n    /// @param _derivativeHash bytes32 Hash of derivative\n    /// @param _derivative Derivative Derivative itself\n    function _initDerivative(bytes32 _derivativeHash, LibDerivative.Derivative memory _derivative)\n        private\n        nonReentrant\n    {\n        // For security reasons we calculate hash of provided _derivative\n        bytes32 derivativeHash = _derivative.getDerivativeHash();\n        require(derivativeHash == _derivativeHash, \"S1\");\n\n        // Get margin from SyntheticId\n        (uint256 buyerMargin, uint256 sellerMargin) = IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);\n        // We are not allowing both margins to be equal to 0\n        require(buyerMargin != 0 || sellerMargin != 0, \"S2\");\n\n        // AUTHOR COMMISSION\n        // Get commission from syntheticId\n        uint256 authorCommission = IDerivativeLogic(_derivative.syntheticId).getAuthorCommission();\n        RegistryEntities.ProtocolParametersArgs memory protocolParametersArgs = registry.getProtocolParameters();\n        // Check if commission is not greater than the max cap set in the Registry by the governance\n        require(authorCommission <= protocolParametersArgs.derivativeAuthorExecutionFeeCap, \"S3\");\n        // Cache values by derivative hash\n        syntheticCaches[derivativeHash] = SyntheticCache({\n            buyerMargin: buyerMargin,\n            sellerMargin: sellerMargin,\n            authorCommission: authorCommission,\n            authorAddress: IDerivativeLogic(_derivative.syntheticId).getAuthorAddress(),\n            init: true\n        });\n\n        // Emits an event upon initialization of a derivative recipe (so only once during its lifecycle)\n        emit LogSyntheticInit(_derivative, derivativeHash);\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/test/upgradeability/TestSyntheticAggregatorUpgrade.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../../core/SyntheticAggregator.sol\";\n\ncontract TestSyntheticAggregatorUpgrade is SyntheticAggregator {\n    function placeholder() external pure returns (string memory) {\n        return \"upgraded\";\n    }\n}\n"
    },
    "contracts/helpers/BalanceHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\ncontract BalanceHelper {\n    struct TokenBalance {\n        uint256 total;\n        uint256 allowance;\n    }\n\n    function balancesOf(address _user, IERC20[] memory _tokens, address _tokenSpender) public view returns (uint256 ethBalance, TokenBalance[] memory tokensBalances) {\n        // Eth balance\n        ethBalance = _user.balance;\n\n        // Tokens balance\n        tokensBalances = new TokenBalance[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            tokensBalances[i] = TokenBalance(\n                _tokens[i].balanceOf(_user),\n                _tokens[i].allowance(_user, _tokenSpender)\n            );\n        }\n    }\n}\n"
    },
    "contracts/test/mocks/synthetics/OptionPutSyntheticIdMock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../../../interfaces/IDerivativeLogic.sol\";\nimport \"../../../helpers/ExecutableByThirdParty.sol\";\nimport \"../../../helpers/HasCommission.sol\";\n\ncontract OptionPutSyntheticIdMock is IDerivativeLogic, ExecutableByThirdParty, HasCommission {\n    uint256 constant BASE_PPT = 1 ether;\n\n    constructor() {\n        emit LogMetadataSet(\n            '{\"author\":\"OpiumDAO\",\"type\":\"option\",\"subtype\":\"put\",\"description\":\"PUT option mock\"}'\n        );\n    }\n\n    /// @return Returns the custom name of a derivative ticker which will be used as part of the name of its positions\n    function getSyntheticIdName() external pure override returns (string memory) {\n        return \"Riccardo's derivative shop\";\n    }\n\n    /// @notice Getter for syntheticId author address\n    /// @return address syntheticId author address\n    function getAuthorAddress() public view virtual override(IDerivativeLogic, HasCommission) returns (address) {\n        return HasCommission.getAuthorAddress();\n    }\n\n    /// @notice Getter for syntheticId author commission\n    /// @return uint26 syntheticId author commission\n    function getAuthorCommission() public view override(IDerivativeLogic, HasCommission) returns (uint256) {\n        return HasCommission.getAuthorCommission();\n    }\n\n    function validateInput(LibDerivative.Derivative calldata _derivative) external view override returns (bool) {\n        if (_derivative.params.length < 1) {\n            return false;\n        }\n\n        uint256 ppt;\n\n        if (_derivative.params.length == 2) {\n            ppt = _derivative.params[1];\n        } else {\n            ppt = BASE_PPT;\n        }\n\n        uint256 strikePrice = _derivative.params[0];\n        return (_derivative.margin > 0 && _derivative.endTime > block.timestamp && strikePrice > 0 && ppt > 0);\n    }\n\n    function getMargin(LibDerivative.Derivative calldata _derivative)\n        external\n        pure\n        override\n        returns (uint256 buyerMargin, uint256 sellerMargin)\n    {\n        buyerMargin = 0;\n        sellerMargin = _derivative.margin;\n    }\n\n    function getExecutionPayout(LibDerivative.Derivative calldata _derivative, uint256 _result)\n        external\n        pure\n        override\n        returns (uint256 buyerPayout, uint256 sellerPayout)\n    {\n        uint256 ppt;\n\n        uint256 strikePrice = _derivative.params[0];\n\n        if (_derivative.params.length == 2) {\n            ppt = _derivative.params[1];\n        } else {\n            ppt = BASE_PPT;\n        }\n\n        if (_result < strikePrice) {\n            uint256 profit = strikePrice - _result;\n            profit = (profit * ppt) / BASE_PPT;\n\n            if (profit < _derivative.margin) {\n                buyerPayout = profit;\n                sellerPayout = _derivative.margin - profit;\n            } else {\n                buyerPayout = _derivative.margin;\n                sellerPayout = 0;\n            }\n        } else {\n            buyerPayout = 0;\n            sellerPayout = _derivative.margin;\n        }\n    }\n\n    function allowThirdpartyExecution(bool allow) public virtual override(IDerivativeLogic, ExecutableByThirdParty) {\n        ExecutableByThirdParty.allowThirdpartyExecution(allow);\n    }\n\n    function thirdpartyExecutionAllowed(address derivativeOwner)\n        public\n        view\n        virtual\n        override(IDerivativeLogic, ExecutableByThirdParty)\n        returns (bool)\n    {\n        return ExecutableByThirdParty.thirdpartyExecutionAllowed(derivativeOwner);\n    }\n}\n"
    },
    "contracts/helpers/ExecutableByThirdParty.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\n/// @title Opium.Helpers.ExecutableByThirdParty contract helps to syntheticId development and responsible for getting and setting thirdparty execution settings\nabstract contract ExecutableByThirdParty {\n    // Mapping holds whether position owner allows thirdparty execution\n    mapping(address => bool) private thirdpartyExecutionAllowance;\n\n    /// @notice Getter for thirdparty execution allowance\n    /// @param derivativeOwner Address of position holder that's going to be executed\n    /// @return bool Returns whether thirdparty execution is allowed by derivativeOwner\n    function thirdpartyExecutionAllowed(address derivativeOwner) public view virtual returns (bool) {\n        return thirdpartyExecutionAllowance[derivativeOwner];\n    }\n\n    /// @notice Sets third party execution settings for `msg.sender`\n    /// @param allow Indicates whether thirdparty execution should be allowed or not\n    function allowThirdpartyExecution(bool allow) public virtual {\n        thirdpartyExecutionAllowance[msg.sender] = allow;\n    }\n}\n"
    },
    "contracts/helpers/HasCommission.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\n/// @title Opium.Helpers.HasCommission contract helps to syntheticId development and responsible for commission and author address\nabstract contract HasCommission {\n    // Address of syntheticId author\n    address private author;\n    // Commission is in Opium.Lib.LibCommission.COMMISSION_BASE base\n    uint256 private constant AUTHOR_COMMISSION = 25; // 0.25% of profit\n\n    /// @notice Sets `msg.sender` as syntheticId author\n    constructor() {\n        author = msg.sender;\n    }\n\n    /// @notice Getter for syntheticId author address\n    /// @return address syntheticId author address\n    function getAuthorAddress() public view virtual returns (address) {\n        return author;\n    }\n\n    /// @notice Getter for syntheticId author commission\n    /// @return uint26 syntheticId author commission\n    function getAuthorCommission() public view virtual returns (uint256) {\n        return AUTHOR_COMMISSION;\n    }\n}\n"
    },
    "contracts/test/mocks/synthetics/OptionCallSyntheticIdMock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../../../interfaces/IDerivativeLogic.sol\";\nimport \"../../../helpers/ExecutableByThirdParty.sol\";\nimport \"../../../helpers/HasCommission.sol\";\n\ncontract OptionCallSyntheticIdMock is IDerivativeLogic, ExecutableByThirdParty, HasCommission {\n    uint256 constant BASE_PPT = 1 ether;\n\n    constructor() {\n        /*\n        {\n            \"author\": \"DIB.ONE\",\n            \"type\": \"option\",\n            \"subtype\": \"call\",\n            \"description\": \"Option Call logic contract\"\n        }\n        */\n        emit LogMetadataSet(\n            '{\"author\":\"DIB.ONE\",\"type\":\"option\",\"subtype\":\"call\",\"description\":\"Option Call logic contract\"}'\n        );\n    }\n\n    /// @return Returns the custom name of a derivative ticker which will be used as part of the name of its positions\n    function getSyntheticIdName() external pure override returns (string memory) {\n        return \"Riccardo's derivative shop\";\n    }\n\n    /// @notice Getter for syntheticId author address\n    /// @return address syntheticId author address\n    function getAuthorAddress() public view virtual override(IDerivativeLogic, HasCommission) returns (address) {\n        return HasCommission.getAuthorAddress();\n    }\n\n    /// @notice Getter for syntheticId author commission\n    /// @return uint26 syntheticId author commission\n    function getAuthorCommission() public view override(IDerivativeLogic, HasCommission) returns (uint256) {\n        return HasCommission.getAuthorCommission();\n    }\n\n    function validateInput(LibDerivative.Derivative calldata _derivative) external view override returns (bool) {\n        if (_derivative.params.length < 1) {\n            return false;\n        }\n\n        uint256 ppt;\n\n        if (_derivative.params.length == 2) {\n            ppt = _derivative.params[1];\n        } else {\n            ppt = BASE_PPT;\n        }\n\n        uint256 strikePrice = _derivative.params[0];\n        return (_derivative.margin > 0 && _derivative.endTime > block.timestamp && strikePrice > 0 && ppt > 0);\n    }\n\n    function getMargin(LibDerivative.Derivative calldata _derivative)\n        external\n        pure\n        override\n        returns (uint256 buyerMargin, uint256 sellerMargin)\n    {\n        buyerMargin = 0;\n        sellerMargin = _derivative.margin;\n    }\n\n    function getExecutionPayout(LibDerivative.Derivative calldata _derivative, uint256 _result)\n        external\n        pure\n        override\n        returns (uint256 buyerPayout, uint256 sellerPayout)\n    {\n        uint256 ppt;\n\n        uint256 strikePrice = _derivative.params[0];\n\n        if (_derivative.params.length == 2) {\n            ppt = _derivative.params[1];\n        } else {\n            ppt = BASE_PPT;\n        }\n\n        if (_result > strikePrice) {\n            uint256 profit = _result - strikePrice;\n            profit = (profit * ppt) / BASE_PPT;\n\n            if (profit < _derivative.margin) {\n                buyerPayout = profit;\n                sellerPayout = _derivative.margin - profit;\n            } else {\n                buyerPayout = _derivative.margin;\n                sellerPayout = 0;\n            }\n        } else {\n            buyerPayout = 0;\n            sellerPayout = _derivative.margin;\n        }\n    }\n\n    function allowThirdpartyExecution(bool allow) public virtual override(IDerivativeLogic, ExecutableByThirdParty) {\n        ExecutableByThirdParty.allowThirdpartyExecution(allow);\n    }\n\n    function thirdpartyExecutionAllowed(address derivativeOwner)\n        public\n        view\n        virtual\n        override(IDerivativeLogic, ExecutableByThirdParty)\n        returns (bool)\n    {\n        return ExecutableByThirdParty.thirdpartyExecutionAllowed(derivativeOwner);\n    }\n}\n"
    },
    "contracts/test/mocks/synthetics/DummySyntheticIdMock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../../../interfaces/IDerivativeLogic.sol\";\nimport \"../../../helpers/ExecutableByThirdParty.sol\";\nimport \"../../../helpers/HasCommission.sol\";\n\ncontract DummySyntheticIdMock is IDerivativeLogic, ExecutableByThirdParty, HasCommission {\n    constructor() {\n        /*\n        {\n            \"author\": \"opium.team\",\n            \"type\": \"synthetic\",\n            \"subtype\": \"none\",\n            \"description\": \"Dummy synthetic for testing purposes\"\n        }\n        */\n        emit LogMetadataSet(\n            '{\"author\":\"opium.team\",\"type\":\"synthetic\",\"subtype\":\"none\",\"description\":\"Dummy synthetic for testing purposes\"}'\n        );\n    }\n\n    /// @return Returns the custom name of a derivative ticker which will be used as part of the name of its positions\n    function getSyntheticIdName() external pure override returns (string memory) {\n        return \"Riccardo's derivative shop\";\n    }\n\n    /// @notice Getter for syntheticId author address\n    /// @return address syntheticId author address\n    function getAuthorAddress() public view virtual override(IDerivativeLogic, HasCommission) returns (address) {\n        return HasCommission.getAuthorAddress();\n    }\n\n    /// @notice Getter for syntheticId author commission\n    /// @return uint26 syntheticId author commission\n    function getAuthorCommission() public view override(IDerivativeLogic, HasCommission) returns (uint256) {\n        return HasCommission.getAuthorCommission();\n    }\n\n    function validateInput(LibDerivative.Derivative memory _derivative) external pure override returns (bool) {\n        _derivative;\n        return true;\n    }\n\n    function getMargin(LibDerivative.Derivative memory _derivative)\n        external\n        pure\n        override\n        returns (uint256 buyerMargin, uint256 sellerMargin)\n    {\n        buyerMargin = _derivative.margin;\n        sellerMargin = _derivative.margin;\n    }\n\n    function getExecutionPayout(LibDerivative.Derivative memory _derivative, uint256 _result)\n        external\n        pure\n        override\n        returns (uint256 buyerPayout, uint256 sellerPayout)\n    {\n        buyerPayout = _derivative.margin;\n        sellerPayout = _derivative.margin;\n        _result;\n    }\n\n    function allowThirdpartyExecution(bool allow) public virtual override(IDerivativeLogic, ExecutableByThirdParty) {\n        ExecutableByThirdParty.allowThirdpartyExecution(allow);\n    }\n\n    function thirdpartyExecutionAllowed(address derivativeOwner)\n        public\n        view\n        virtual\n        override(IDerivativeLogic, ExecutableByThirdParty)\n        returns (bool)\n    {\n        return ExecutableByThirdParty.thirdpartyExecutionAllowed(derivativeOwner);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}